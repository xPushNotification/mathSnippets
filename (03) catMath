01. РАССТОЯНИЕ МЕЖДУ ТОЧКАМИ:
-----------------------------

    Есть возможность использовать 2D/3D, уквадраченное и нет расстояние.

    а) Найти сдвиг от начала системы координат:

        dX = Ax - Bx
        dY = Ay - By
        dZ = Az - Bz

    б) Исходя из тиоремы Пифагора, надем длину для вектора/расстояние между точками:

        length(dist) = sqrt(dX*dX + dY*dY + dZ*dZ)

02. ОПРЕДЕЛЕНИЕ ВЕКТОРА:
------------------------

    Вектор представляется как точка <x.y.z> или как линия, берущая начало в <0.0.0>
    и идущая до <x.y.z>

    Используя вектор представляют направление.

    Вектор может быть добавлен, умножен (масштабирован), отражен.

    Нахождение длины вектора есть оптимизированное нахождение длины линии:

    length  = |<x.y.z> - <0.0.0>|
            = |(x-0)*(x-0) + (y*0)*(y*0) + (z-0)*(z*0)|
            - sqrt( pow(x,2) + pow(y,2) + pow(z,2) )

    Для нахождения самого короткого вектора в массиве ищется 
    самый короткий квадрат длины, без извлечения квадратного корня.

    Для создания относительности и для поиска через DotProduct угла между векторами
    вектор преобразуется в Unit вектор, т.е. вектор, имеющий длин 1.

    length = |<Vx.Vy.Vz>|

    UnitV =     <Vx.Vy.Vz>
                ----------
                length

    Следует заметить, что нахождение Unit коэффициентно зависимо:

    Vx+Vy+Vz = some                     Vx
    --------                    <=>     --          = значение от 0 до 1
    length   = some                     length

    При отсутствии Z части имеется:

    Vy                              Vx
    --              =       1 -     --
    length                          length

    Вектор определяется от конечной точки к начальной (не наоборот):

    Vector = EndP - BegP

03. ОПРЕДЕЛЕНИЕ ЛИНИИ
---------------------

    Линия представляется или через 2 точки, или через параметрику

    P1 = <x1.y1.z1>                 Origin = <x1.y1.z1>
    P2 = <x2.y2.z2>                 Direction = P1-P2 = <x1-x2. y1-y2. z1-z2>

    Параметрическое представление:

    <Xn.Yn.Zn> = <OrgX.OrgY.OrgZ> + ( K * <DirX.DirY.DirZ> )
    при К >= 0 и К < 1

    использование уравнения линии для интерполяции между точками произвольными
    называется LERP - linear interpolation.

    SLERP - в свою очередь используется для интерполяций вращений,
    то есть это интерполяция по кругу или сфере -с помощью параметра,
    опять же функции включены в любую стандартную мат.библиотеку

    часто, для интерполяции как в сценарии ниже для замены SLERP
    можно использовать LERP то есть сделать интерполяцию между
    A и B и после этого установить длину вектору в 1цу,
    по факту получиться как раз аналог SLERP
    (но совпадение все равно будет не 100% ным)

       / A
      /
     /
    /___ B

    Надо понимать - что уравнение линии это ФУНКЦИЯ.
    то есть её можно нарисовать на графике с Х-Y осями.
    то есть ею вычисляется ЗАВИСИМАЯ переменная Y - от независимой
    переменной-параметра Х (функция движется по Х и рисует Y)

    предположим у нас есть зависимость зарплаты от времени работы
    формула будет
    у = b0 + b1 * x
    y -> зарплата
    x -> время работы
    в этом случае b0 -> это начальная зарплата с которой начинается исчисление
    b1 -> размер slope полагающийся на один год (например рост 10к за год)
    то есть цифры в функции будут:
    b0 = 30к
    b1 = 10к
    чем больше b1 - тем более агрессивной будет линия вверх
    так в примере мы получим:
    0 лет работы = 30к                    <=> у = f(x=0) = 30k + 10k*(x=0)
    1 год работы = 30к+10к*1              <=> у = f(x=1) = 30к + 10к*(x=1)
    2 года работы = 30к+10к*2             <=> у = f(x=2) = 30к + 10к*(x=2)

    при этом если на Y в функции оказывает влияние один х
    это называется Simple Linear Regression, а если несколько х
    то Multiple Linear Regression
    y = b0 + b1*x1                           SLR:одна зависимость (опыт-зарплата)
    y = b0 + b1*x1 + b2*x2 +.. bn*xn         MLR:несколько зависимостей (machine learning)
                                             (опыт-зарплата И возраст-зарплата И..)
                                             - для вычисления корреляций и зависимостей
                                             - sigmoid для статистики

04. ЛУЧ/ПРЯМАЯ:
---------------

    Луч есть параметрическое представление линии, с ограничением лишь со стороны K >= 0
    Прямая есть линейное, параметрическое уравнение, без ограничения со стороны K.

05. 2D/3D DotProduct:
---------------------

    DotProduct это проецирование (тень) одного вектора на другой по длине.

    C помощью DotProduct ищутся любые отклонения векторов относительно друг друга,
    и связанные с этим эффекты (если вы смотрите кому то в глаза - DotProduct == -1)

    Если взять DotProduct от вектора самого себя, и извлечь квадрат, то мы получим его длину
    (очевидно - что длина вектора составляет 100% проекции самого вектора на самого себя).

    DotProduct же показывает на сколько длина ДРУГОГО вектора коррелируется 
    его расположением на САМ вектор, проще говоря показывает cos от одного вектора к другому
    (cos - отношение одного вектора к другому, а отношение это длина этого вектора)

    Очевидно, также - что если вектор перпендикулярен другому, то его проекция на такой 
    вектор будет равна нулю. (как у тени в полдень), вот поэтому и cos от 90 градусов равен нулю
    (cos и DotProduct это фактически одно и тоже).

    То есть если вектора совсем рядом - DotProduct равен единице,
    если перпендекулярны - то он равен нулю,
    а если расположены вот так:

    <------.------> то минус единице.

    Ну и также естественно, что cos нужно искать для векторов равных единице в длину (Unit векторов), 
    иначе их не равная длина будет искажать значения, и невозможно будет понять какой на 
    самом деле угол (длины же векторов будут разными, и при наложении друг на друга не дадут единицы,
    а соотношение длин и соотношение углов работает только лишь при равной длине векторов,
    а чтобы можно было бы извлекать acos - то еще и ограниченных в длину единицею).

    Value
        = A*B
        = Ax*Bx + Ay*By + Az*Bz

    Полученное value есть косинус (отношение вектора к вектору) угла образованного векторами 
    чтобы найти сам угол, надо выполнить acos.

    Чтобы не получилось искажение отношения, а искался именно угол,
    надо чтобы вектора были Unit.

    theta = acos*( Dot(Unit(A),Unit(B))  )
    theta_digree = theta / 0.01745f

    Через DotProduct можно найти лишь внутренний угол до 180% (тень то не может быть 360 градусной)

    Если нужно найти угол свыше 180 градусов, то сначала определяется ACW/CW расположение векторов,
    и только потом ищется угол:

    (180 + 180 - угол) -> 
    (360 - угол)

    Чтобы определить лишь четверть расположения угла (от 0 до 90, от 90 до180), не надо вычислять acos.

06. 2D ВРАЩЕНИЕ
---------------

    Представляет вращение вокруг псевдоопределенной Z оси

    cos - изменяется от 0 до 1 
    sin - изменяется от 0 до 1
    c интервалом в 90 градусов, если этот интервал привязать 
    не только к одной координате, но к двум - движение станет круговым.

    Данное вращение возможно лишь для точки, лежащей относительно начала системы координат.

    x = cos(theta) * x      -       sin(theta)*y
    y = sin(theta) * x      +       cos(theta)*y

    Для вращения вокруг произвольной точки лежащей в XY плоскости, делаем так:

    а) сдвигаем вращаемую точку к центру системы координат на значения точки
    вокруг вращаемся 
    б) произведем вращение
    в) сдвинем точку обратно

    Объединенная формула (theta - уголь в радианах):

    x1  =       (   cos(theta) * (x-OrgX)       -       sin(theta)*(y-OrgY)     )  + OrgX
    y1  =       (   sin(theta) * (x-OrgX)       +       cos(theta)*(y*OrgY)     )  + OrgY

07. CW/ACW РАСПОЛОЖЕНИЕ:
------------------------

    Исходим из того, что ни один угол в многоугольнике не может быть >180 градусов, 
    то есть если угол > 180 градусов, - это внешний угол.

    Также для определения CW/ACW требуется, чтобы полигон был выпуклым.

    Определение:
    
    а) Возьмем выпуклый полигон, от которого возьмем 3 произвольные точки:

    P1-->P2
    |     |
    v     |
    P4---P3

    б) Рассчитаем два вектора, образованные этими точками:
    
    E1 = P2-P1
    E2 = P4-P1

    в) Ищем угол между двумя векторами, если меньше 180 градусов, то CW метод, если больше то ACW

    P1-->P2     CW  - угол P4-P1-P2 - будет внутренний < 180 градусов
    ^     |
    |     v
    P4<--P3

    P1<--P2     ACW - угол P2-P1-P4 - будет внешним > 180 градусов
    |     ^
    V     |
    P4-->P3

    Для нахождения угла:

    Сдвинем Е2 на 90 градусов, для того чтобы мы могли проверять угол между -90 градусами и 90 градусами
    (или соответственно - cos 0 и 1)

    (1)
    |
    |
    |-------- (0)
    |
    |
    (-1)

    При сдвиге для CW метода получим:
    
    было:

    |------>
    ^
    |
    |

    стало (угол заметно уменьшился и теперь нахождение Dot вернем >= 0):

    ^\
    | \
    |  \

    При сдвиге для ACW метода получим:

    было:
    
    |
    |
    v
    |-----> 

    стало (угол заметно увеличился и теперь нахождение Dot вернет <0):

    |
    |
    v
     \
      \
       \

    Для 3D для разворачивания угла используется Cross-овая ось векторов для вращения

    Исходя из того, что сдвиг на 90 градусов представляется через:

    x1  =   -y
    y1  =   x

    Составим формулу для определения CW/ACW:

    CW = false; ACW = false;

    if( (E1x*E2y     -       E1y*E2x)   >= 0 )      {CW = true;}
    else                                            {ACW = true;}

    Z составляющая не имеет значения в 2D случае.

    Определение режима CW/ACW полигона важно для выстраивании нормали полигона в 3D пространстве:

    Для CW:

             ^
             |
      (p2)---|------(p3)
      /      |      /
     /             /
    (p1)--------(p4)


    Для ACW:            
              
       (p1)----------(p4)
       /            /
      /      |     /
     (p2)----|---(p3)
             |
             v

08. 90 ГРАДУСНЫЕ СДВИГИ ДЛЯ ОСУЩЕСТВЛЕНИЯ БЫСТРОЙ РОТАЦИИ (В 2Д/3Д С ИСПОЛЬЗОВАНИЕМ Z ЧАСТИ)
--------------------------------------------------------------------------------------------

    естественно будет работать, если точки вращаются вокруг центра системы
    координат.

    90 градусов:

        x1 = -y
        y1 = x

    180 градусов:

        x1 = -x
        y1 = -y

    270 градусов (-90 градусов):

        x1 - y
        y1 = -x

    Соответственно в формуле получаем (2D CrossProduct):

    x1  =   cos(-90deg) * x     -       sin(90deg)*y    =   y
    y1  =   sin(-90deg) * x     +       cos(90deg)*y    =   -x


09. SIN/COS - 90 ГРАДУСНЫЕ ЗНАЧЕНИЯ (ЧЕТВЕРТИ):
-----------------------------------------------

    Исходим из того, что угол представлен в радианах:

    sin:
    ----

    -0.5   0   0.5
        \  |  /
         \ | /
          \|/
    -1  ---.---  1
          /|\
         / | \
        /  |  \
    -0.5   0   0.5

    sin0   =  0
    sin90  =  1
    sin180 =  0
    sin270 = -1
    sin360 =  0

    cos:
    ----

    0.5    1   0.5
        \  |  /
         \ | /
          \|/
     0  ---.---  0
          /|\
         / | \
        /  |  \
    -0.5   1   -0.5    

    cis0   =  1
    cos90  =  0
    cos180 = -1
    cos270 =  0
    cos360 =  1

    Исходя из представленных значений, инверсия sin/cos 
    будут происходить следующим образом:

    sin(n) = cos(n-90deg)
    cos(n) = sin(n+90deg)

    Значения при шаговых значениях asin и acos:

    asin(0)     =    0rad = 0deg
    asin(1)     =    1.57rad = 90deg
    asin(0)     =    0
    asin(-1)    =   -1.57rad = -90deg

    acos(1)     =    0rad = 0deg
    acos(0)     =    1.57rad = 90deg
    acos(-1)    =    3.14rad = 180deg


10. ПРЕДСТАВЛЕНИЕ КРУГА:
------------------------

    При круге, отцентрированном в центре системы координат, с R = радиусу, 
    круг представляется через следующее уравнение:

    pow(x,2) + pow(y,2) - pow(R,2) = 0

    - или - 

    pow(x,2) + pow(y,2) = pow(R,2)


    исходя из:

                .....
            _d^^^^^^^^^b_
         .d''           ``b.
       .p'                `q.
      .d'                   `b.
     .d'                     `b.
     ::              R        ::
     ::           x.........> ::
     ::                       ::
     `p.                     .q'
      `p.                   .q'
       `b.                .d'
         `q..          ..p'
            ^q........p^
                '''''

    R   == length(<0.0.0> - <x.y.0>)    

    pow(R,2) 
        == pow(length,2) 
        == pow(x,2) + pow(y,2)

    Можно классифицировать точку относительно круга в центре системы координат
    следующим образом:

    pow(Xn,2) + pow(Yn,2) - pow(R,2) <  0            - точка лежит в круге
    pow(Xn,2) + pow(Yn,2) - pow(R,2) == 0            - точка лежит на круге
    pow(Xn,2) + pow(Yn,2) - pow(R,2) >  0            - точка лежит за пределами круга

    Также можно классифицировать круг относительно круга 
    (если круг представлен через точку и радиус):

    D   =   sqrt( pow(dx,2)+pow(dy,2)  )             - расстояние между точками центров

    при:

    D >  R1 + R2         - не соприкасаются (расстояние до точки меньше R)    
    D == R1 + R2         - соприкасаются в 1ой точке 
    D <  R1 + R2         - соприкасаются в 2ух точках


11. ОПРЕДЕЛЕНИЕ ПЛОСКОСТИ:
--------------------------

    Плоскость представляется как сплошная многоугольная поверхность, представленная 
    через нормаль и скалярное К, причем под нормалью подразумевается направление
    в котором плоскость повернута.

    \     ^               ^ <-   +N
     \    |               |
      \   |       \-------|--------\
       \  |--------\------| Plane   \
        \ |         \----------------\
         \|               | <-   K
          \--------------------------->
           \              |
            \             |
             \            v <-  -N
              \

    Под нормалью сожкт быть представлена
    прямая по которой скользит плоскость

    -К - представляет собою удаление от центра по нормали

    В параметрическом представлении плоскости К представляет собою место на нормале,
    где плоскость находится.

    Для того чтобы найти К для каждой конкретной плоскости используется предопределенная
    точка этой плоскости и её нормаль, из чего К уникально для каждой конкретной 
    плоскости с заданной нормалью.

    <x.y.z> * <nx.ny.nz> = K            <- DotProduct от точки и нормали

    Математическое представление:

    Ax + By + Cz + D = 0

    при <x.y.z> - точка, <A.B.C> - нормаль и D = -K, т.е.

    Ax + By + Cz - K = 0

    Можно рассмотреть отношение (классификацию) точки к плоскости:

    <x.y.z> * <nx.ny.nz> = K      - или     - точка принадлежит плоскости
    <x.y.z> * <nx.ny.nz> - K = 0            
                                            
    <x.y.z> * <nx.ny.nz> > K      - или     - точка спереди плоскости (в направлении нормали) 
    <x.y.z> * <nx.ny.nz> - K > 0            на значение больше 0-ля
                                                                                        
    <x.y.z> * <nx.ny.nz> < K      - или     - точка сзади плоскости на значение меньше 0-ля
    <x.y.z> * <nx.ny.nz> - K < 0            

    Исходя из того, что расстояние от точки до плоскости ищется по 
    следующей формуле: (оно должно быть положительно)
    можно формировать переднее и заднее усечение

    Distance =  |   <x.y.z> * <nx.ny.nz> - K    |

    Plane Forward Culling / Plane Back Culling:

                |                    |
    (отсечено)  |<-----(наблюдатель)-| (остечено зад)
                |                    |

12. 3D CROSS PRODUCT:
---------------------

    Через CrossProduct можно получить перпендекуляр к 2м векторам
    (а если вектора стороны полигона, то нормаль полигона)

    AxB = 
        <
            Ax*Bz  -   Az*By     .                (yz-zy) -> x
            Az*Bx  -   Ax*Bz     .                (zx-xz) -> y
            Ax*By  -   Ay*Bx                      (xy-yx) -> z
        > 

    При нахождении 3D CrossProduct используется как и в 2D псевдоротация на 90 градусов.

    CrossProduct в отличае от DotProduct возвращает вектор.

    При расчете каждой из осей, эта ось (её значение) отсутствует.

    При BxA получится -(AxB) <- (ACW/CW расположение полигона важно)

    Для <1.0.0>x<0.1.0> - получим Z ось <0.0.1> которая является перпендикуляром 
    к обоим веторам.

    ACW/CW можно воспринимать не как порядок даже точек как, а как порядок векторов в операции
    AxB - перпендикуляр в одну сторону
    BxA - перпендекуляр в другую сторону
    
    этим, например и отличаются левосторонние и правосторонние системы координат.
    
    <1.0.0> x <0.1.0> = <0.0.1>
    <0.1.0> x <1.0.0> = <0.0.-1>

    Для ненормализованных векторов длина нормали образованной через CrossProduct
    равняется площади фигуры образованной двумя треугольниками, образуемыми векторами
    из которых CrossProduct вычислялся

    соответственно площадь треугольника, образованного векторами - это |A x B| / 2

    ^
    |   A
    |  /|\
    | / | \
    |/  |  \
    x   |   x
     \  |  /
      \ | /
       \|/
        B

    Для ненормализованных векторов CrossProduct ближе к нулю, чем ближе 
    вектора друг от друга отстоят (площадь же у них меньше получается), 
    и больше к 1 если вектора перпендекулярны,
    и соответственно опять стремится к нулю
    в ситуации (опять же площадь пропадает):

    <------------x------------>

xx. ОТРАЖЕНИЕ ОБЪЕКТА ОТ ПОВЕРХНОСТИ:
-------------------------------------
            normal
            |    ray
            |   /
    reflсt  |  /
          \ | /
           \|/
    -----------------
           /|  
          / | length = dot(normal,ray)        
     projct = dot(normal,ray) * normal


    Сначала мы найдем длину пробития ray от нормали через DotProduct
    зная глубину пробития - мы можем получить вектор предсталяющий это пробитие
    (projct)

    теперь нужно лишь сдвинуть точку пробития вверх х2 раза - по направлению нормали
    и мы получим отражение (reflct)

    теперь можно получить или направление отражения, 
    или высоту отражения (от силы ray).

    и полная формула:
        ray - 2*dot(n,ray)*n

13. РАСЧЕТ ПЛОСКОСТИ ИЗ 3Х ТОЧЕК:
---------------------------------

    Для создания потребуется:
    а) Создать два вектора (P1P2) и (P3P2)
    б) Расчитать через 3D CrossProduct к ним нормаль
    в) Взять любую точку и расчитать плоскостное K
    г) Необходимо учитывать порядок точек (CW->Z=1, ACW->Z=-1)

    Расчет:
        normal<x.y.z> = (P1-P2) x (P3-P2)
        K = normal<x.y.z> * P1<x.y.z>

    Для получения CW нормаль от полигона:
        normal = (P1-P2) x (P3-P2)

    для ACW нормаль для полигона:
        normal = (P3-P2) x (P1-P2)

14. 3D РОТАЦИЯ В РАДИАНАХ ВОКРУГ ЦЕНТРА СИСТЕМЫ КООРДИНАТ (НЕ ОБЪЕДИНЯЕМАЯ)
---------------------------------------------------------------------------

    Такое вращение не объединяемое, то есть вращение вокруг одно
    из осей - собьет вращение вокруг других
    для того чтобы вращаться корректно, всегда следует 
    перерассчитывать относительную ось вращения и использовать вращение
    вокруг произвольной оси.

    Это же вращение корректно будет работать, если будет задейстована 
    только одна ось (это например произойдет в 2D)

    Вокруг X:

        x1 = x
        y1 = cos(theta)*y - sin(theta)*z
        z1 = sin(theta)*y + cos(theta)*z

    Вокруг Y:

        x1 = cos(theta)*x + sin(theta)*z
        y1 = y
        z1 = -sin(theta)*x + cos(theta)*z

    Вокруг Z:

        x1 = cos(theta)*x - sin(theta)*y
        y1 = sin(theta)*x + cos(theta)*y
        z1 = z

15. ПЕРЕСЕЧЕНИЕ МЕЖДУ ЛИНИЕЙ И ПЛОСКОСТЬЮ:
------------------------------------------

    Алгоритм нахождения того, стоит ли искать точку пересечения:

    if(  ClassifyPointPlane(P1, plane) * ClassifyPointPlane(P2, plane) > 0   )  {return false;}

    То есть,
    обе точки находятся с одной стороны плоскости, 
    - нет ни одного отрицательного значения в расстоянии

    Нахождение точки пересечения:

    Пересечение происходит, если точка одновременно удовлетворяют уравнениям 
    плоскости и линии:

        (1) p = org + V * dir
        (2) p * normal - K = 0

    то есть точка пересечения находится объединением двух формул в одну.

    Начнем такое преобразование (объединение происходит на точке p,
    то есть вместо p в одной формуле - вставим вторую):

        V * dir * normal = K - org * normal

    Теперь мы можем найти параметр V для уравнения линии:

        V = (K-org*normal) / (dir*normal)

    Подставив представление V в уравнение линии, мы получим точку пересечения
    конкретной линии с конкретною плоскостью:

        P_int<x.y.z> = org<x.y.z> + ( (K-org*normal)  /  (dir*normal)  ) * dir<x.y.z>

    При нахождении точки пересечения следует учитывать:

        (1) Если dir*normal (их dot) == 0, линия проходит параллельно плоскостиЕ:

        ------------->  normal
          |
          |
          v             theta = 90 градусов, acos(0) = 90 градусов

        ------------->  dir

        (2) Любое параметрическое уравнение может быть объединено с другим 
        для поиска геометрических точек их пересечения, будь то формула чего угодно
        с формулой чего угодно, пока есть и там и там точка - её можно найти.


xx. ИЗ ГЛОБАЛЬНЫХ КООРДИНАТ В ЛОКАЛЬНЫЕ:
----------------------------------------

    |
    |   \              
    |    \         __/
    |     \     __/
    |      \ __/
    |       /
    |               (X)
    |
    |
    |------------------------


    Локальные координаты во первых смещены
    во вторых они повернуты

    1. То есть точку надо сначала сместить в локальные координаты
    2. а потом повернуть её в них.

    поворот ищется через DotProduct между локальной системой координат
    (её осями) и локальной системой координат (её осями).

    Vector2 objPos = transform.position;        // точка начала локального объекта
    Vector2 right = transform.right;            // ось локального обьекта Х
    Vector2 up = transform.up;                  // ось локального объекта Y

    Vector2 WorldToLocal(Vector2 worldPt)
    {
        Vector2 relPoint = worldPt - objPos;
        float x = Vector2.Dot(relPoint, right);
        float y = Vector2.Dot(relPoint, up);

        return new Vector2(x,y);
    }

    Преобразование из локальных координат в глобальные решается с помощью
    скалирования локальной точки на её же локальные оси
    (локальные оси уже сдвинуты в пространстве, поэтому на них и можно скалировать)

    Vector LocalToWorld(Vector localPt)
    {
        Vector2 worldOffset = right*localPt.x + up*localPt.y;
        return (Vector2)transform.position + worldOffset;
    }

    Если подумать о том что делают матрицы,
    то они именно и делают подобные преобразования:
    они представляют оси координат относительно друг друга
    после чего ищут смещение и поворот - и делают преобразования.

    а перемножение матриц - это преоразования последовательные
    из одной системы координат в другую, с помощью тех самых
    DotProducts.

    то есть для матриц:

    (А)
    1 0 0   это положение осей локального объекта следующей матрицы
    0 5 0 
    0 0 2 

    (В)
    5 0 0   это локальные координаты точки <5.4.1> в координатах этой матрицы
    0 4 0 
    0 0 1 

    А*B = глобальные координаты точки <5.4.1>
    при условии что последний ряд будет в обоих матрицах 1.1.1 и 1.1.1
    само по себе смещение финальное - не имеет отношения к матрицам как к таковым
    оно скорее представляет изменения для отдельно взятого случая

    Проще говоря преобразование с помощью матриц работает так:
        Local Position
        ->
        Transform Point
        -> 
        World Position
        ->
        Inverse Transform Point
        ->
        Local Position

    И опять же - это абсолютно тоже самое что последовательное 
    преобразование с помощью формул DotProduct для осей.
    Так как матрицы ЭТО И ЕСТЬ ОСИ координат, относительно друг друга
    в том порядке - в котором матрицы друг с другом перемножаются.

xx. КОСИНУС И СИНУС:
--------------------
            
            |
            |____<x.y>        a = угол между xy и осью Х
    sin(a)  ^   /|            в этом случае, - sin - длина проекции на Y ось
            |  / |            cos - длина проекции на X ось
            | /  |
            |@a  |  
            |----|---------
             cos(a)

    При том - если угол будет вращаться по кругу, а вектора будут unit, 
    cos/sin будут рисовать соответственно значения с уменьшением и увеличением 

    очевидно также, почему например при 90% угле cos будет равен 0лю,
    а sin будет равен 1-це.
    отражения на оси Х фактически нет
    а отражение на оси Y полное
    
    ^  cos(90) = 0, sin(90) = 1
    |
    | 
    |
    x

    при угле 0 градусов,- cos(0) = 1, sin(0) = 0 (максимальная проекция на Х ось,
    нет проекции на Y ось)

    x------->

    очевидно также что cos и sin ходят друг за другом, потому что чем больше тень
    проекции от синуса, тем меньше от косинуса и наоборот,
    это и позволяет рисовать круг с этими двумя формулами.

    ну и очевидно, что arccos(1) да 90 градусов, только, представленные в радианах
    (6.24 = tau - которая равна 2Пи)
    90 * 6.28/360

    DotProduct коррелируется с cos/sin в той части, что cos/sin 
    это DotProduct между вектором и осью X (представим, что А это вектор, а B это ось Х).

    dot(A,B) == |A|*|B|*cos(a)
    или:
    dot(UnitA, UnitB) = 1*1*cos(a) = cos(a)

    Если оперирутся с помощью векторов, длиною в 1, 
    можно, только зная угол, получить координаты вектора:
    
        cos(a) = V.x
        sin(a) = V.y

    обратно будет работать для 0deg < a < 180deg,
    опять же при длине в 1
    (ограничение связано с тем - что в определении 
    полного угла - использется квадратный корень,
    и не понятно к какой половине относится ответ)

        acos(v.x) = a
        asin(v.y) = a

    и отсюда же, но уже определение реального угла:
    (clamp функция нужна для того чтобы из за ошибок вычислений 
    с плавающей точкою - не вышло так, что в функцию acos попало значение
    которое бы вызвало undefined значение в ответ)

        acos
        ( 
            clamp(  dot(unitA, unitB),     -1,      1    ) 
        ) = a

16. ПЕРЕСЕЧЕНИЕ МЕЖДУ ЛИНИЕЙ И СФЕРОЮ:
--------------------------------------

    Пересечение происходит когда точка (пересечения) одновременно удовлетворяет 
    уравнениям линии и сферы:

    (1) p = org + V * dir
    (2) | p - origin | = radius       - или -       (pn - originn)^2 = radius^2

    следует найти такое V при котором линия пересеклась бы со сферою

    * Подставим из 1го уравнения во 2е:

    |(org + V*dir) - origin| = radius

    * устраним модуль:
    
    ((org + V*dir) - origin)^2 = radius^2

    * раскроем квадратное уравнение, в котором V будет корнем:

    V^2 + dir^2 + V*2*dir*(org-origin) + (org+origin)^2 = 0

    * Рассмотрим решение через оптимизированную формулу:

    V = -B   +/-   sqrt(B2-4AC)/2A

    где:

    A = dir^2
    B = 2*dir*(org-origin)
    C = (org-origin)^2

    Только при V >= 0 и V <= 1 точки соответствуют линии

    * При -V точка org ближе к сфере, чем её конец (1*dir)

    dir^2  -- DotProduct от самого себя

    если А = 0 линия не пересечётся со сферою (можно возвратить ближайшую точку)

    если sqrt(B^2 - 4AC) = 0, - линия касается сферы в 1ой точке, где V = -B/2A

17. ПЕРЕСЕЧЕНИЕ МЕЖДУ КУБОМ И СФЕРОЮ:
-------------------------------------

    inline float squared(float v) { return v * v; }
    bool doesCubeIntersectSphere(vec3 C1, vec3 C2, vec3 S, float R)
    {
        float dist_squared = R * R;
        /* assume C1 and C2 are element-wise sorted, if not, do that now */
        if (S.X < C1.X) dist_squared -= squared(S.X - C1.X);
        else if (S.X > C2.X) dist_squared -= squared(S.X - C2.X);
        if (S.Y < C1.Y) dist_squared -= squared(S.Y - C1.Y);
        else if (S.Y > C2.Y) dist_squared -= squared(S.Y - C2.Y);
        if (S.Z < C1.Z) dist_squared -= squared(S.Z - C1.Z);
        else if (S.Z > C2.Z) dist_squared -= squared(S.Z - C2.Z);
        return dist_squared > 0;
    }

    bool BoxIntersectsSphere(Vec3 Bmin, Vec3 Bmax, Vec3 C, float r) {
    float r2 = r * r;
    dmin = 0;
    for( i = 0; i < 3; i++ ) {
        if( C[i] < Bmin[i] ) dmin += SQRT( C[i] - Bmin[i] );
        else if( C[i] > Bmax[i] ) dmin += SQRT( C[i] - Bmax[i] );     
    }
    return dmin <= r2;
    }

18. ПЕРЕСЕЧЕНИЕ МЕЖДУ СФЕРОЮ И ПОЛИГОНОМ:
-----------------------------------------

    В определении используются расчеты:
    1. Столкновение сферы с плоскостью
    2. Определение нахождения точки плоскости внутри полигона
    3. Проецирование центра сферы на плоскость
    4. Нахождение ближайшей точки на линии к произвольной точки

    Определение происходит в 4е шага:

    Шаг 1. 
    Проверям на столкновение полигона (его плоскости) со сферою, если этого 
    не происходит - заканчиваем тестирование на коллизию

    Шаг 2.
    Получение точки пересечения плоскости и полигона + использование определения
    того, лежит ли данная точка внутри полигона (определение луч/полигон
    столкновения)

    Мы знаем, что можем получить вектор нормали от полигона, что покажет нам 
    в какую сторону этот полигон направлен. Через ClassifyPoint мы 
    можем найти расстояние от центра сферы до полигоновой плоскости.

    При перемещении нормали плоскости на дистанцию мы получим смещение 
    от центра сферы до плоскости, вычтя которое мы спроецируем центр
    сферы на плоскость.

    (Можно использовать расчеты из шага 1, для получения расстояния от
    центра сферы до полигона (плоскости полигона))

              ^ NP             (*)              (NP*dist) - смещение от плоскости до центра сферы
      /-------|-----------------|-dist-/  
     /        |                 v     /   
    /--------------------------------/

              ^ NP                              CentreSph - (NP*dist) = ProjCentrSph
      /-------|------------------------/     
     /        |                (*)    /         
    /--------------------------------/

    Шаг 3.
    Теперь точку центра проверим на нахождение внутри полигона, если
    это сработает, то можно прекращать поиск стоклновения (столкновение есть)

    Шаг 4.
    Подразумевается следующая ситуация:

              ^ NP 
      /-------|------------------------/     
   (*)        |                       /         Центр не лежит внутри полигона, 
    /--------------------------------/          но пересечение есть.

    Для определения того, есть ли в данном случае столкновение,- проверим на столкновение 
    ребер полигона со сферою, точнее самых ближайших точек на этих ребрах.

    те при:

        Distance(  NearPountOnN, CenterSph  ) <= RadiusSph

        Имеется столкновение при N подразумевающее каждую из граней.

    Алгоритм:

    bool SpherePolygonCollision(CVector3 vPolygon[], int vertexCount, CVector& vCenter, float radius)
    {
        // шаг 1.
        CVector3 vNormal = Normal(vPolygon);
        float distance = 0.0f;
        int classification = ClassifySphere(vCenter, vNormal, vPolygon[0], radius, distance);

        if(classification != INTERSECTS) return false;

        // шаг 2 и 3.
        CVector3 offset = vNormal * distance;
        CVector3 vPosition = vCenter - offset;

        if(InsidePolygon(vPosition, vPolygon, vertexCount)) return false;

        // шаг 4.
        if(EdgeSphereCollision(vCenter, vPolygon, vertexCount, radius)) return false;

        return true;
    }

    19. НАХОЖДЕНИЕ БЛИЖАЙШЕЙ ТОЧКИ НА ЛИНИИ К ЗАДАННОЙ ТОЧКЕ:
    ---------------------------------------------------------

    CVector3 ClosestPointOnLine(CVector3 vA, CVector3 vB, CVector3 vPoint)
    {
        CVector3 vVector1 = vPoint - vA;        // вектор от vA к нашей точке
        CVector3 vVector2 = Normilize(vB-vA);   // направление vBvA

                              vPoint
          vVector1        ___/
                     ___/
                ___/
           ___/
          /         vVector2
       vA *-------------------------* vB

        // Находим длину vAbB, и затем проецируем vVector1 на vVector2

        float d = distance(vA, vB);
        float t = dot(vVector2, vVector1);


                               vPoint
          vVector1        ___/|
                     ___/     |
                ___/          |
           ___/               |
          /         vVector2  |
       vA *-------------------|----* vB
                              |
                                vP = vA + t*( Unit(vA-vB) )

        // определим расположение проекции с параметром t напрямую vAvB, если
        // проекция будет перекрывать ограничители vA и vB, будем возвращать их, иначе
        // проекцируем точку

        if(t<=0) return vA;
        if(t>=0) return vB;

        CVector3 vClosestPoint vA + (vVector2 * t);
        return vClosestPiunt;
    }

20. ПРОЕЦИРОВАНИЕ ТОЧКИ НА ПЛОСКОСТЬ
------------------------------------

    Шаг 1. Получаем удаление от точки до плоскости

        float dist = x*nx + y*ny + z*nz - K

    Шаг 2. Получим вектор смещение от точки до плоскости

        V3 offset = {nx*dist, ny*dist, nz*dist};

    Шаг 3. Вычитаем смещение точки и получаем проекцию

        V3 PrjPoint = { x-offset[_x],    y-offset[_y],    z-offset[_z]  };

21. ПЕРЕСЕЧЕНИЕ МЕЖДУ СФЕРОЮ И ПЛОСКОСТЬЮ
-----------------------------------------
    Для определения пересечения требуется определить боьлше ли расстояние 
    от центра сферы до плоскост, чем радиус сферы

    if(  abs(nx*cx + ny*cy + nz*cz - K) <= radius  )
    {
        intersection = true;
    }

22. ОПРЕДЕЛЕНИЕ НАХОЖДЕНИЯ ТОЧКИ ВНУТРИ ВЫПУКЛОГО ПОЛИГОНА (CONVEX)
-------------------------------------------------------------------
    Для данного определения используем метод нахождения суммы углов между всеми
    линиями, проведенными ко всем точкам прямоугольника.

    1                         2
    |-------------------------|
    |\__                   __/|
    |   \__             __/   |
    |      \__  @a   __/      |
    |     @d  \__ __/ @b      |
    |       __/ @g  \__       |
    |    __/           \__    |
    | __/                 \__ |
    |/_______________________\|
    4                         3

    Во время прохода смотрим углы 12, 23, 34, 41 (т.е. образованные веторами из сторон
    и сторонами).

    Точка внутри, если: a+b+g+d = 360 градусов

    При несоблюдении данного равенства точка лежит вне полигона:

    1                         2
    |-------------------------\_
    |\______                  | \_
    |       \_______          |   \_
    |               \_________|_    \_
    |                         | \=====(*)
    |               __________|_/  _/
    |       _______/          |  _/
    | _____/                  |_/
    |/________________________|/
    4                         3

    a+b+g+d < 360 градусов

    Сумма углов, образованных точкою и сторонами convex полигона не может быть 
    > 360 градусов, причем если точка лежит снаружи полигона,
    то сумма > 360 градусов, а если внутри == 360 градусов.

    Общее нахождение (алгоритм):

    1. Устанавливаем, что точка и полигон лежат в одной плоскости:

    vNormalPlane = vP1 - vP2  x   vP3 - vP2
    Kp1 = vP1 * vNormalPlane

    Если уже известно, что точка и полигон лежат в 1ой плоскости,
    или ищется для projective шаг 1 пропускается.

    2. Считаются углы:

    double angle_all = 0;
    V3 vA, vB;              // для формирования углов

    for(int i = 0; i< num_vert; i++)
    {
        vA = polygon[i];
        vB = polygon[(i+1)%num_vert];
        angle_all += AngleBetween(vA, vB);

        // Подразумевается, что считается относительно точки, т.е. правильно будет или 
        // сдвинуть полигон к центру (vA-pt, vB-pt => AngleBetween), либо AngleBetween(pt, vA, vB)
    }

    if(angle_all >= 360) return true;
    return false;

23. ПЕРЕСЕЧЕНИЕ МЕЖДУ СФЕРОЮ И ПРЯМОЮ
-------------------------------------

    Для поиска пересечения сначала ищеться расстояние от центра сферы до 
    прямой и сравнивается с радиусом сферы

    Очевидно, что расстояние от точки до прямой есть расстояние от точки М до 
    точки N пересечения прямой с перпендикулярной ей плоскости, проведенной через M

                .....
            _d^^^^^^^^^b_
         .d''           ``b.
       .p'                `q.
      .d'                   `b.
     .d'                     `b.
     ::    R     M            ::
     :: <---------x           ::
     ::           | D         ::
     `p.          |          .q'
    -------------------------------
       `b.       N         .d'
         `q..          ..p'
            ^q........p^
                ''''''
    При D < Radius - столкновение есть.

    Плоскость перпендикулярна прямой и проходящая через М задается уравнением:

        l*(x-x0) + M*(y-y0) + N*(z-z0) = 0

        где:
        lmn - радиус вектор
        xyz - параметрическая точка
        x0y0z0 - точка через которую проходит плоскость (задаваемая - наша М)
                    
    Подставив параметрическое уравнение прямой в уравнение плоскости, найдем значение
    параметра t, определеющего координаты точки N пересечения прямой и плоскости

    t = (lx0 + my0 + nz0 - (lx0 + my0 + nz0)) / (l*l + m*m + n*n)

    xyz    - конечная точка
    lmn    - радиус вектор
    x0y0z0 - начальная точка

    Если заранее нормировать вектор lmn, то уравнение примет вид:

    t = lx0 + my0 + nz0 - (lx0 + my0 + nz0)

24. СТОЛКНОВЕНИЕ ЛИНИИ И СФЕРЫ
------------------------------
    
    Аналогично алгоритму поиска ближайшей точки прямой и центра сферы,
    по линии в части сравнения коэфициентов, как ближайшие не возвращаем концы, 
    а возвращаем true или false.

    bool SphereLineCollision(sph_c, radius, p1, p2)
    {
        CVector3 vVector1 = spch_c - p1;
        CVector3 vVector2 = p1 - p2;
        vVector2.normilize();

        float d = distance(p1,p2);
        float t = dot(vVector1, vVector2);

        if(t<=0)
        {
            if(dist_sqr(p1, sph_c) <= sph_radius*sph_radius) return true;
            return false;
        }
        if(t > d)
        {
            if(dist_sqr(p2, sph_c) <= sph_radius*sph_radius) return true;
            return false;
        }

        // ищем точку, зная что ближайшая точка принадлежит линии:

        CVector3 nearest = p1 + (vVector2 * t);
        if(dist_sqr(nearest, sph_c) <= radius*radius) return true;
        return false;'
    }

25. ОПРЕДЕЛЕНИЕ ПРИНАДЛЕЖНОСТИ ТОЧКИ ПРЯМОЙ К ОТРЕЗКУ НА ЭТОЙ ПРЯМОЙ
--------------------------------------------------------------------

    Для нахождения следует подставить точку в уравнение прямой,
    полученное от линии и сравнить диапазон полученного t с рамками 0 и 1

    Pзаданная = P1 + (t * (P1-P2))  <=> t * (P1-P2) = Pзаданная - P1 <=>

    t = (Pзаданная - P1)   /   (P1 - P2)

    при t >= 0, t <= 1 точка принадлежит линии.
    
    t ищется для xy или z от Pn

26. ПЕРЕСЕЧЕНИЕ ДВУХ AABB (AXIS ALIGNED BOUNDING BOXES)
-------------------------------------------------------

    Выравненный по осям означает, что его стороны перпендекулярны координатным осям

    При наличии 2х ААBB, заданных положением своих центров в пространстве и 
    размерами. Чтобы определить, пересекаются ли эти AABB нужно спроецировать их
    на каждую из координатных осей и проверить пересекаются ли полученные проекции.

    | 
    |__ ___ ______
    |         |xxx|
    |__ ___ __|xxx|     
    |_ ____   |   | 
    |  |xxx|  |   |
    |_ |xxx|  |   |
    |__|___|__|___|_________

    Если пересекаются все проекции, то ААВВ пересекаются, тест обязателен по всем осям

    Алгоритм:

    vec3_t A;
    vec3_t ASize;
    vec3_t B;
    vec3_t BSize;

    если расстояния между центрами AABB больше суммы радиусов ААВВ,-
    они пересекаются, иначе,- не пересекаются.

    bool AABBsOverlap(void)
    {
        for(int i=0; i<3; i++)  // перебираем оси
        {
            // если проекции не пересекаются,- возвращаем false
            if( fabs((A[i] - B[i])) > ASize[i]/2 + BSize[i]/2  ) return false;
        }
        return true;
    }

    Непересекаются:

        A    D    B
        ___________
        |R1     R2|
    |___|___|  |__|___|
    
    Пересекаются:

        A  D   B
        ________
        |R1    |
    |___|___|  |
             R2|
           |___|___|

27. ПЕРЕСЕЧЕНИЕН ДВУХ OBB (ORIENTED BOUNDING BOXES)
---------------------------------------------------

    OBB описываются через координаты центра
    размера и ортогональный базис (т.е. направление локальных
    координатных осей)

    С учетом этого базиса координаты должны быть приведены
    к мировым, после чего OBB должны быть проецированы
    на оси - где проверка должна стать аналогичной AABB.

28. ОБЪЕКТНО ОРИЕНТИРОВАННЫЙ СДВИГ (СТРЕЙФ)
-------------------------------------------

    Данный вид движения в 3D достигается расчетом result_x оси с 
    использованием явно задаваемой UpV и меняющегося vect_x

        UpV
      |
    \ |
     \|
      \-----------> vect_x
       \
        \ рассчитанная 
         \  result_x

    Движение можно сделать монотонным, если использовать
    Unit представление полученной result_x оси.

    void strafe(float speed)
    {
        float result_x, result_y, result_z;

        calc_cross(&result_x, &result_y, &result_z,   UpX, UpY, UpZ,   Mx, My, Mz);

        pos_x += result_x * speed;
        pos_y += result_y * speed;
        pos_z += result_z * speed;

        vect_x += result_x * speed; 
        vect_y += result_y * speed;
        vect_z += result_z * speed;
    }

29. ДВИЖЕНИЕ ТОЧКИ ВОКРУГ ПРОИЗВОЛЬНОЙ ОСИ
------------------------------------------

    Произвольная ось представляется в виде вектора.

    Алгоритм вычисления ротации:

    1. Транслируем все пространство до того места где линия берет своё начало,
    делаем это через вычитание начальной точки линии от всех точек,
    также в дальнейшем потребуется инверс к этой матрице:

    F = 
    1           0           0           -ox
    0           1           0           -oy
    0           0           1           -oz
    0           0           0           1

    Finv = 
    1           0           0           ox
    0           1           0           oy
    0           0           1           oz
    0           0           0           1

    2. Вращаем пространство вокруг Z оси, так чтобы линия вращения
    проходила в XZ плоскости

    G = 
    dx/v        dy/v        0           0
    -dy/v       dx/v        0           0
    0           0           1           0
    0           0           0           1

    Ginv = 
    dx/v        -dy/v       0           0
    dy/v        dx/v        0           0
    0           0           1           0
    0           0           0           1

    При построении инвесрной матрицы использовалось правило матриц, по 
    которому инверсия М для М вращения это её транспонированный вариант.

    V = длине вектора ( V = sqrt(dx^2 + dy^2))
    
    Соответственно, на данный момент, имеем новую линию вращения с одним 
    концом в Org (центр системы координат), а другим в <v.0.dz>
    
    3. Развернем постранство вокруг Y оси, т.к. линия вращения проходит по 
    Z оси (сдвинемся на V)

    H = 
    dz/w        0           -v/w        0
    0           1           0           0
    v/w         0           dz/w        0
    0           0           0           1

    Hinv = 
    dz/w        0           v/w         0
    0           1           0           0
    -v/w        0           dz/w        0
    0           0           0           1

    где:
    w = sqrt(v^2 + dz^2) = sqrt(dx^2 + dy^2 + dz^2)
                                ------------
                                  исходя из 

                                  sqrt(dx^2 + dy^2) * sqrt(dx^2 + dy^2)
                                  = dx^2 + dy^2

    4. На данный момент ось вращения проходит по Z оси между точками <0.0.0>
    и <0.0.w> и есть возможность вращать пространство вокруг Z оси:

    w = 
    cosA        -sinA       0           0
    sinA        cosA        0           0
    0           0           1           0
    0           0           0           1

    5. Для достижения корректноо вращения используем следующую матрицу:

    Mrot_result = F x G x H x W x Hing x Ging x Fing
    
    (в реальности мы матрицы перемножать не будем в динамике,
    а будем использовать просто итоговую - формулу - так как в ней
    будут как раз и заложены все нужные нам преобразования пространств)

    Представление подобного вращения в объектном алгоритме:

    Рассматривается корректный и некорректный поворот (вокруг изменяемой оси
    объекта и вокруг статической UpV - вращение вокруг будет нормальным,
    но при поднятии взгляда вверх будет вонзикать эффект шеи,
    то есть обороты будут становиться меньшего радиуса)

    ^ UpV
    |....>  радиус оборота небольшой вращение "не корректное"
    |   /
    |../..>  радиус оборота чуть меньше
    | /__/ 
    |//
    |.......> радиус оборота полный

    то есть вращение вокруг X корректное, а вокруг Y нет
    заметим, если реализовывать оба вращения корректно будет эффект 
    не человеческой головы на шее, а вращающегося через себя космического
    корабля.

    void RotateAroundPos(float angle, bool pov_x, bool pov_y)
    {
        if(pov_y)
        {
            // используется корректное вращение вокруг псевдо Х оси объекта
            // так как данная ось не представлена явно, найдем её 
            // через использование CrossProduct

            //-> найдем направление "взгляда" объекта:

            float move_x = vect_x - pos_x;
            float move_y = vect_y - pos_y;
            float move_z = vect_z - pos_z;

            //-> ищем через CrossProduct локальную псевдо Х ось, учитывая, что UpV 
            // был задан явно (шея всегда смотрит вверх от поверхности)

            float result_x = ((move_y * up_z) - (move_z * up_y));
            float result_y = ((move_z * up_x) - (move_x * up_z));
            float result_z = ((move_x * up_y) - (move_y * up_x));

            //-> преобразуем полученный вектор в юнит представление:
            // шаг может быть порпущен, если move_xyz уже unit

            float dist = (float) sqrt(
                result_x*result_x +
                result_y*result_y + 
                result_z*result_z
            );

            result_x /= dist;
            result_y /= dist;
            result_z /= dist;

            //-> осуществляем собственно вращение вокруг произвольной оси
            // здесь это result_xyz
            // можно использовать как отдельную функцию

            float new_x = 0, new_y = 0, new_z = 0;
            float view_x = 0, view_y = 0, view_z = 0;

            // представим в view_n move_n представление, так как именно этот вектор
            // будем вращать (для наглядности)

            view_x = move_x;
            view_y = move_y;
            view_z = move_z;

            angle *= 0.01745f;

            float cosTheta = (float)cos(angle);
            float sinTheta = (float)sin(angle);

            // эмулируем прохождение точки через матрицу (развернутую матрицу):
            // в самом вычислении в таком виде разума и смысла искать нет никакой необходимости

            x_axis = result_x;
            y_axis = result_y;
            z_axis = result_z;

            new_x =  (cosTheta + (1-cosTheta)*x_axis*x_axis) * view_x;
            new_x += ((1-cosTheta)*x_axis*y_axis-z_axis*sinTheta) * view_y;
            new_x += ((1-cosTheta)*x_axis*z_axis+y_axis*sinTheta) * view_z;

            new_y =  ((1-cosTheta)*x_axis*y_axis - z_axis*sinTheta)*view_x;
            new_y += (cosTheta+(1-cosTheta)*y_axis*y_axis)*view_y;
            new_y += ((1-cosTheta)*y_axis*z_axis-x_axis*sinTheta)*view_z;

            new_z =  ((1-cosTheta)*x_axis*z_axis - y_axis*sinTheta) * view_x;
            new_z += ((1-cosTheta)*y_axis*z_axis + x_axis*sinTheta) * view_y;
            new_z += (cosTheta + (1-cosTheta)*z_axis*z_axis)*view_z;

            // так как мы производим вращение вокруг центра системы координат, - 
            // сдвинемся обратно (vect_xyz == vect_n):
            vect_x = pos_x + new_x;
            vect_y = pos_y + new_y;
            vect_z = pos_z + new_z;
        }

        //-> некорректное вращение (head shift rotation
        if(pov_x)
        {
            // здесь выполняется GimballLock вращение, так как изменением угла 
            // между UpV и VectX мы не изменяем UpV, получая эффект шеи

            rot_ar_axis(angle, UpX, UpY, UpZ);
        }
    }

30. ФОРМУЛЫ СОКРАЩЕННОГО УМНОЖЕНИЯ:
-----------------------------------

    эти неочевидные формулы применяются в большинстве формул 
    преобразования, раскрытия скобок и подобного
    сильно "уродуя" смысл формул, однако для вычислений
    итоговых - их надо бы тоже знать

    (a+b)^2 = a^2 + 2ab + b^2
    (a-b)^2 = a^2 - 2ab + b^2
    (a+b)(a-b) = a^2 + b^2
    (a+b)^3 = a^3 + 3a^2b + 3ab^2 + b^3
    (a [+/-] b )(a^2 [+/-] ab + b^2) = a^3+b^3

32. КВАДРАТНЫЕ УРАВНЕНИЯ:
-------------------------

    Использование квадратных уравнений (поиск корней)
    используется тогда когда какая то фигура выраженная квадратной функцией
    ищет свое пересечение с линией

    например круг пересекается сферою
    1 корень - на круге
    2 корня - протыкает
    нет корней - проходит мимо

    Уравнения вида 
        
        ax^2 + bx + c = 0       
        
    где  a,b,c - действительные числа, и a!=0
    называются квадратными, при а=1 уравнение "приведеное", а при а!=1 - нет

    a- первый коэфициент
    b- второй коэфициент
    c- свободный член

    Корни уравнения вычисляются по формуле:

    x = 
        +(-b) [+/-] sqrt(b^2 - 4ac)
        ---------------------------
                    2a
    Выражение 
    
        D = b^2-4ac 
    
    называется дескриминантом квадратного уравнения (дескриминант - значет определитель наличия решений).

    Если D < 0, - уравнение не имеет действительных корней
    если D = 0, - имеется один квадратный корень
    если D > 0, - имеются 2а квадратных корня

    При D = 0 говорят, что уравнение имеет 2а одинаковых корня.

    Используя представление D можно написать формулу: 

        x = (-b [+/-] sqrt(d)) / 2a

    Если K = b/2 (т.е. b = 2K), то формула примет вид:

        x = 
            -K [+/-] sqrt(K^2-ac)
            ---------------------
                      a

    Данная формула удобна если К- целое число, т.е.
    b - четное число ((bчетное % 2) = 0)

    Неполное квадратное уравнение:

    Если в квадратном уравнении b или C равняется 0, то уравнение 
    неполное и проще решить уравнения, - разложением его любой части на 
    множетели.

    Теорема Виета:

    Если квадратное уравнение приведено (a=1), то 
    
        x^2 + px + q = 0

    имеет действительные квадратные корни, их сумма = -p, а
    произведение = q, т.е.

        x1 + x2 = p
        x1 * x2 = q

    Биквадратные уравнения:

        ax^4 + bx^2 + c = 0     где a!=0

    данное уравнение рассчитывается через введение новой переменной:

        x^2 = y

    получаем:

        ay^2 + bq + c = 0

    корни которого ищутся как:

        x1 = sqrt(y1)
        x2 = -sqrt(y2)

33. ПЕРЕВОД ИЗ ГРАДУСОВ В РАДИАНЫ
---------------------------------

    pi = 180
    pi/2 = 90

    в представлении на радианы

    Для преобразования радиан в градуы используем коэффициент:

    1 градус = (3.14 / 180) радиан

    отсюда:

    digr = radians * (pi/180)
    radians = digr * (180/pi)

34. РАССЧЕТ СТОРОН ТРЕУГОЛЬНИКА
-------------------------------

    Любая сторона треугольника может быть предсталена из 2х других
    исходя из теоремы косинусов:

    a^2 (любая сторона) = b^2 + c^2 - (2bc * cos(угол_между_BC))

    для равнобедренного треугольника: a = b = c
    для прямоугольного: a^2 = b^2 + c^2 

    квадрат гипотинузы равен сумме квадратов катетов

35. ИСПОЛЬЗОВАНИЕ ЛИНЕЙНОГО УРАВНЕНИЯ ДЛЯ ПРЕОБРАЗОВАНИЯ ИЗ VIEWPORT В WINDOW КООРДИНАТЫ
----------------------------------------------------------------------------------------

    Предположим, что мы имеем некоторую логическую точку, логического окошка, а нам 
    требуется перенести эту точку на конкретную физику (2n логику)

    Например у нас расширение логическое в экране 800x600 - а пользователь разворачивает 
    окно на весь экран.

    Используем следующее уравнение:
    (в примере используется Viewport->Window)

    Some_point = Ph_x_org + ( K_отношение_логики_к_физике * offset_x_logic )        

    Что применительно к конкретным координатам нам дает:
    Dx = Vox + (Vex / Wex * (Lx - Wox))

    где:

    Vex/Wex - есть коэфициент отношения координат окошка к физическим
    координатам, т.е. коэфициент модификации логического сдвига, для 
    того, чтобы он соответствовал сдвигу в ViewPort.

    Lx-Wex - здесь мы получаем сдвиг для точки в Window
    (т.е. сдвиг в VP с учетом размещения, исходя из начала Window)

    Добавляя к полученной Viewport offset точке Vox мы получаем относительный / пропорциональный
    сдвиг от начала физического окошка.


    Vox+
    -----------------
    |               |
    |   viewport    |
    |<------------->|
    |   Vex         |
    |               |
    |_______________|

    Wox+
    -----------------
    |   Lx*K        |
    |----->         |
    | window        |
    |<------------->|
    | Wex           |
    |_______________|

    Порядок преобразований:

        V->W => K1 = W/V => V*K
        W->V
        K2 = V/W => K2 = 1 / (W/V) = V/W

    Исходя из представленного примера делаем следующие выводы:

    1. Для +/- масштабирования требуется использовать +/- оператор к Vex/Wex
    значению

    2. При Vex/Wex получаем коэфициент преобразования из W в V, а при 
    Wex / Vex из V в W, т.е. при V = 2 и W = 3, для преобразования из V в W
    используется коэфициент 3/2, а в W в V используется коэфициент 2/3.

    V->W = V*K => K = W/V       из чего преобразовываем на то и делим
    W->V = W*K => K = V/W

    3. Принципы подобного уравнения применимы к любым относительным осям,
    при Dir в уравнении линии, трактуемой как сдвиг.

36. КРИВЫЕ БЕЗЬЕ
----------------

           P2    P3 
           /     \
          / . .. .\
         /.       .\
        /.         .\
        P1          P4

   (0*t)------------->(1*t)

    Логическое построение кривых методом Безье
    используя уравнение кривой можно контролировать 
    количество разбиений кривой.

    Данный тип кривой задается параметрически и рисуется при помощи
    нахождения заданного числа равностоящих друг от друга точек на кривой
    и последующего их соединения прямыми линиями.

    Базовая функция (функция прямой):    t + (1-t) = 1

    Соответственно наиболее простая прямая, это прямая 1ой степени.
    Так как кривая Безье является полиномом, то представленное выше уравнение
    даст нам прямую линию.

    Исходя из того, что данная функция истинна при всех значениях t мы 
    можем взять для решения куб, квадрат, гиперкуб и тд.

    Так как для работы с 4мя точками нам потребуется 3я (куб) степень:

    (t+ (1-t))^3 = 1^3      <=>

    t^3 + 3t^2 * (1-t) + 3*t*(1-t)^2 + (1-t)^2 = 1

    исходя из:
    (a+b)^3 = a^3 + 3a^2b + 3ab^2 + b^3 

    где:
    a = t
    b = (1-t)

    Данный вид уравнения является наиболее общим, так как:

    1. Это уравнение с самой низкою степенью, которое не обязательно должно
    лежать в одной плоскости

    2. Касательные линии к сторонам не зависят друг от друга
    (в полином 2ой степени есть лишь 3-и контрольные точки)

    Полином 2ой степени можно использовать для сглаживания углов:

    P2      P3
    _________
    |   . . . 
    | . 
    |.
    |.
    P1

    Так как в результирующей части уравнения стоит 1-ца, можно
    говорить о том, что если сложить все элементы, то можно 
    определить долю каждой точки в уравнении

    (Участие доли в уравнении при формировании единицы итоговой)

    Когда мы хотим вычислить значение точки, находящейся 
    на кривой,- мы просто умножаем каждую компоненту
    уравнения на свою контрольную часть (или вектор)
    и находим сумму, следовательно работает по следующей формуле:

    Pon_curve = 

    P1<x.y.z> * t^3 + 
    P2<x.y.z> * 3 * t^2 * (1-t) + 
    P3<x.y.z> * 3 * t * (1-t)^2 + 
    P4<x.y.z> * (1-t)^3

    при 0<=t<=1
    при t == 0, - получаем P1
    при t == 1, - получаем P4

    Причем генерируемая точка через t никогда не пройдет через P2/P3, 
    это следует учитывать при работе с кривыми (точки нельзя использовать 
    как опорные для вычислений, потребуется рассчитать новые,
    а вот P1/P2 могут быть опорными)

37. КРУГОВОЕ ДВИЖЕНИЕ, БАЗИРУЮЩИЕСЯ НА ШАГЕ
-------------------------------------------

    Для прохождения круга следует постепенно наращивать угол от 0rad до (2*3.14)rad = 360deg
    на шаг равный 1deg = ((2*3.145)/360)

    Пример осуществления тройного прохода:

    for(angle = 0; angle < (2*Pi*3); angle += (2*Pi/360))
    {
        x = cos(angle)*radius;
        y = cos(angle)*radius;
    }

    sin/cos операции могут применяться как к XY так и к YX комбинации
    (измениться порядок обхода

    Метод может использоваться для создания вписанных полигонов
    (квадрат вписанный в круг, треугольник вписанный в круг)
    когда задается количество точек полигона, 
    и получаются в итоге нужные точки.

    при стороне равной 360/num_points

    for(angle = 0; angle < 360*ToRads; angle += 360 * ToRads/num_points)
    {
        point[i][x] = sin(angle)*radius;
        point[i][y] = cos(angle)*radius;
    }

38. УСТАНОВКА НОВОЙ ДЛИНЫ ВЕКТОРА
---------------------------------

    float len = sqrt(x*x + y*y + z*z)
    float new_len = искомая_длина

    // метод работает аналогично преобразованию из V в W 
    // координаты, т.е. V->W => V*K => K = W/V

    if(len != 0)        <- xyz = 0
    {
        x *= new_len / len;
        y *= new_len / len;
        z *= new_len / len;
    }

    пример рассчета:

        старя длина = 1
        при x = 1, y = 0, z = 0
        новая длина = 2

        коэфициент отношения строй длины к новой: 2/1 = 2
        новые координаты:

        x = x*2 = 2
        y = 0
        z = 0

39. АЛГОРИТМ НАХОЖДЕНИЯ КОРНЕЙ КВАДРАТНОГО УРАВНЕНИЯ
----------------------------------------------------
    int quadRoots(double a,double b,double c,double* r1,double* r2)
    {
    if ( a != 0 ){
        // 2nd order equation
        if ( b*b - 4*a*c > 0 ){
            r1[0] = (-b + sqrt(b*b - 4*a*c)) / (2 *a);
            r2[0] = (-b - sqrt(b*b - 4*a*c)) / (2 *a);
            r1[1] = 0;
            r2[1] = 0;
            return (2);
        }
        else if ( b*b - 4*a*c == 0 ) {
            r1[0] =  (-b )/(2 *a);
            r2[0] =  0;
            r1[1] =  0;
            r2[1] =  0;
            return (1);
        }
        else {
            // ( b*b - 4*a*c IS < 0 )
            // complex roots
            r1[0] = -b / (2 *a);
            r2[0] = -b / (2 *a);

            r1[1] = sqrt( 4*a*c - b*b) / (2 *a);
            r2[1] = -r1[1];
            return (2);
        }
    }
    else if (b != 0 ){
        // firts order equation
        r[0] = -c/b;
        return (1);
    }
    else {
        // a == 0 && b == 0
        // c = 0 ???
        return (0);
    }

40. ПРОЕЦИРОВАНИЕ КВАДРАТНЫХ КООРДИНАТ В МНОГОУГОЛЬНИК
------------------------------------------------------

    то есть, есть ST координаты предсталяющие собою логические XY
    и есть какой нибудь кривенный полигон - на которые эти ST надо разместить
    (например для текстурирования или нанесения объекта какого равномерно)

    решение включает 2а этапа:
    1. многоугольник разбивается на несколько треугольних областей (их зоны)
    2. исходя из массивов длин будем проецировать ST квадратные координаты

    Алгоритм:
    void TriangleAreas(Point3* vertices, int vcount, float* areas)
    {
        int i; 
        float area_sum = 0;
        Vector3 v1, v2, v3;

        // рассчитываем зоны:
        for(i = 0; i< vcount-2; i++)
        {
            v1 = vertices[i+1] - vertices[0];
            v2 = vertices[i+2] - vertices[0];
            v3 = cross(v1,v2);

            areas[i] = length(v3);

            areas_sum += areas[i];
        }

        // общая сумма cross-ов должна быть равна 1, 
        // для достижения совместимости с ST
        
        for(i=0; i< vcount-2; i++)
        {
            areas[i] /= area_sum;
        }
    }

    void Square_to_polygon(
        Point3* vertices,
        int vcount,
        float* areas,
        float S, float T,
        Point3* p
    )
    {
        int i;
        float area_sum = 0;
        float a,b,c;

        // найдем индекс зоны в которую будут спроецированы координаты
        for(i=0; i< vcount-2; i++)
        {
            area_sum += areas[i];
            if(area_sum >= S) break;        // наша зона
        }

        // размещаем S
        S = (S-area_sum + areas[i]) / areas[i];

        // размещаем T
        T = sqrt(T);
        a = (1-T);
        b = (1-S)*T;
        c = S*T;

        // размещаем в треугольник:
        p.x = (a*vertices[0].x) + (b*vertices[i+1].x) + (c*vertices[i+2].x);
        p.y = (a*vertices[0].y) + (b*vertices[i+1].y) + (c*vertices[i+2].y);
        p.z = (a*vertices[0].z) + (b*vertices[i+1].z) + (c*vertices[i+2].z);
    }

41. МАТЕМАТИЧЕСКИЕ МАКРОСЫ
--------------------------

    #define abs(a) (a>0)?(a):(-a)
    #define round(a) (a>0)?(int)a+0.5 : -(int)0.5-a;
    
    #define sgn(a) (a>0)?1:-1
    #define sqrt(a) (a*a)

    #define min(a,b) (a>b)?b:a

    #define swap(a,b) a^=b; b^=a; a^=b;

    #define DTOR 0.017453
    #define RTOD 57.29578

    #define newtype(x) (x*)malloc(sizeof(x))

    #define clamp(val, min, max) (val<min)?(val = min) : ( (val>max)?(val = max):(val = val) )

    #define expand(vec)     (vec).x, (vec).y, (vec).z

    #define diff(x,y) (x<y)?(y-x):(x-y)

    #define signum(a) (a>0) ? 1 : ((a<0) ? -1 : 0)

    #define index_forward(i,num) i=(i+1)%(num)

42. ДЕЛЕНИЕ ЧЕРЕЗ УМНОЖЕНИЕ
---------------------------

    считается, что операция умножения проходит быстрее чем операция деления
    то есть можно разделить один раз преобразовав, а потом много раз умножать

    b = b/c
    d = 1/c
    b*d = b* (1/c) = b/c

    пример:

    vector^ vector::operator/= (float& s)
    {
        float r = 1/s;
        this->x *= r; 
        this->y *= r;
        this->z *= r;

        return *this;
    }

43. ОПЕРАТОРЫ С++ ЧЕРЕЗ МАТЕМАТИКУ (%, XOR)
-------------------------------------------

    % операция:

        a = b % c 
        a = b - ((b/c) * c)     при условии использования int

            b/c * c     - целые разы
            b           - целые разы и остаток

        a = 7%5 = 2
        a = 7 - (7/5 * 5) = 2

        В коде:

        t = r/h
        r = r-(t*h)

    xor операция:

        R = R^h

        ex = R;
        if(h == 0) R = 1;
        else 
            for(i=h-1; i>0; i--) R = R*ex;

44. ПРОСТЕЙШАЯ ИНТЕРПОЛЯЦИЯ МЕЖДУ ДВУМЯ ЗНАЧЕНИЯМИ
--------------------------------------------------

    исходим из общей базовой функции: 1 = t + (1-t)

    P = P1*t + P2 * (1-t)

    при увеличении t движение происходит от P2 к P1

    t = 1
    P1 = P1 
    P2 = 0
    Pres = P1

    t = 0
    P1 = 0
    P2 = P2 
    Pres = P2

    вообще чтобы двигаться корректно от P1 в сторону P2:

    Pres = P1*(1-t) + P2*t

45. ПОЛУЧЕНИЕ RANDOM ЗНАЧЕНИЙ ПРОИЗВОЛЬНОГО ДИАПАЗОНА
-----------------------------------------------------

    float rand_diap(float P1, float P2)
    {
        int random = rand()%1000;
        float random_t = ((float)random)/1000.0f;
    }

    float get_random(float min, float max)
    {
        float randomNum = (float) rand() / 0x7fff;
        float num = min + (max - min) * random_num;

        return num;
    }

46. ИНТЕРПОЛЯЦИЯ МЕЖДУ МАССИВОМ ТОЧЕК
-------------------------------------
    корректная при одинаковом расстоянии между точками,

    почему так, смотрим отклонения:

    все что касается статистики и поиска отклонений 
    это и есть интерполяция корректная между значениями 
    где например точки еще и вес имеют
    для того чтобы одна точка, выбивающаяся из общей кучи 
    не сбивала среднюю точку по направлению к этой точке

    вес может представляться как усреднение значений точек 
    на все присутствующие рядом, прежде чем вычислять их центр

    то есть некорректно вычислить усреднение и выдать его за центр
    а корректно произвести вычисление усреднения - скорректировать на него
    значения точек - после чего вычислять центр

    (а)-----(б)--(с)
        два расстояния: 5 и 2
        усредненное растояние:
        (5+2) / 2 = 3.5 => 3

        те расстояния которые не выбиваются из среднего остаются такими как и есть
        те кто выбиваются - весом тащим к тем кто не выбивается:

    (а)---(б)--(с)
        и вот здесь уже можно искать центр

    чем больше будет усреднений - тем ближе центр вычисляемый
    будет к общей куче расположения точек

    это кстати и имеется в дурных формулах исскуственного интеллекта
    при построении матрицы принятия решения на базе базовых данных

    вернемся к интерполяции:

    ну так вот, в формуле усреднение не учитывается
    то есть надо или разбивания создать - то есть добавить новые точки
    которые будут одинаковой длины
    или пойти сложным путем и считать в том числе веса
    при осуществлении движения (сегмент будет искаться не по индексу, а по длине,
    то есть длина сегментов станет частью вычислений)

    но мы будем просто двигаться внутри одного массива,
    смещаясь равномерно

    void Interpolate(V3* array, int ar_size, float t, V3 result)
    {
        clamp (t, 0,1);
        float summ = 0;

        for(int i = 0; i < ar_size-1; i++)
        {
            summ += distance_sq(array[i], array[i+1]);
        }

        float pro_summ = summ*t;

        for(int j = 0; j < ar_size; j++)
        {
            float dist_to = DistanceToIndexedPoint(array, array_size, i);

            if(dist_to > pro_summ)  // наш сегмент
            {
                float segment_t = 0;
                float diff = dist_to - pro_summ;
                float s_dist = distance(array[j-1], array[j]);
                segment_t = diff / s_dist;

                interpolate(array[j], array[j-1], segment_t, result);
                return;
            }
            else if(dist_to == pro_summ)
            {
                result[0] = array[j][0];
                result[1] = array[j][1];
                result[2] = array[j][2];
                return;
            }
        }
        result[0] = result[1] = result[2] = 0;
    }

47. РАССЧЕТ ЦЕНТР ИЗ МНОЖЕСТВА ТОЧЕК (+СМ. ИНТЕРПОЛЯЦИЮ МЕЖДУ МАССИВОМ ТОЧЕК)
-----------------------------------------------------------------------------

    Сразу понимаем что центр будет статистически не корректным,
    если какое то значение выбивается сильно из общей массы

    Центр от N точек рассчитывается как:

    dist = (сумма длин от 0 до N точки) / N

    Алгоритм:

    for(int i = 0; i< number_verts; i++)
    {
        m_vCenter.x += pVertices[i].x;
        m_vCenter.y += pVertices[i].y;
        m_vCenter.z += pVertices[i].z;
    }
    m_vCenter /= number_verts;

48. ВРЕМЕННЫЕ ТРЕКИ (ТЕКУЩИЙ ПРОИГРЫВАЕМЫЙ КАДР АНИМАЦИИ)
---------------------------------------------------------

    Временной трек (t) есть интерполяция из множества кадров 
    с использованием:

    t = (T-T1) / (T2-T1)

    при:
    T2-T1 - количество кадров
    T - текущее время

    T-T1 - выравнивание на разницу
    T2-T1 - общее время

              T1       T2
              |        |
              |==T     |
    (0)---(1)---(2)---(3)
               <- трек

    t = (2-15) / 2.5-1.5
    0.5 / 1 = 0.5 (относительно 1го маркера времени)

49. FRUSTRUM
------------

    Фруструм представляет собою куб из 6ти уравнений плоскости
    (точнее это шесть уравнений плоскости внутри которых образовалось
    пространство куба)


       .+------+  
     .' |    / |  
    +   |   /  |  
    | --->     |  
    |  .+-^----+  
    |.'   |  .'   
    +------+'     

    При p-центральной точке и size-радуусе куба,
    создается кубический frustrum:

    пл1К = <0.1.0>  *Py - size
    пл2К = <0.-1.0> *Py + size
    пл3К = <1.0.0>  *Px - size
    пл4К = <-1.0.0> *Px + size
    пл5К = <0.0.1>  *Pz - size
    пл6К = <0.0.-1> *Pz + size

    Исходя из теста произвольной точки на все 6ть уравнений можно определить
    лежит ли точка внутри или снаружи frustrum-a

    Также для теста можно использовать матрицу

50. ОПРЕДЕЛЕНИЕ СФЕРЫ ЛЕЖАЩЕЙ В FRUSTRUM
----------------------------------------

    Тестируя на расстояние от центра сферы до каждой из плоскостей 
    (n = {1,2,3,4,5,6}) frustrum-a:

    при:
        (Сx*An + Cy*Bn + Cz*Cn - Dn) >= 0       центр в фруструм

    при:
        (Cx*An + Cy*Bn + Cz*Cn - Dn) >= 0 - radius      сфера внутри
        <=>
        (Cx*An + Cy*Bn + Cz*Cn - Dn) + radius >= 0

    Также можно использовать нахождение D для нахождения расстояния от сферы до 
    плоскости.

51. ОПРЕДЕЛЕНИЕ МАТРИЦ
----------------------

    Матрица представляет собою 2Д массив числовых данных:

    m = 
    00          01          02          03 -> Mij = M03
    10          11          12          13
    20          21          22          23
    30          31          32          33

    Порядок матрицы определяется MxN при M строки, а N столбцы

    Точка в пространстве представляется так:

    x   - координаты
    y
    z
    1   - предполагаемое движение (обычно 1)

    Изменение позиции точки через матрицу (изменение векторов)
    достигается с помощью перемножения точки на матрицу:

    A           B           C           D 

    *

    x
    y
    z
    w

    = 

    (x*A) + (y*B) + (z*C) + (w*D)
    
    Пример:

    точка 
    x
    y
    z
    w

    информация об изменении: 

    1           0           0           4
    <- сохранить старое значение        <- данный сдвиг

    При преобразовании получаем (для Х части): 
    (x*1)+(y*0)+(z*0) + (w*4) = x+4

    Практически имеет место быть перемножение вектора на матрицу:

    1       0       0       4           x
    <-----------------------------------
    0       1       0       0          |y
    0       0       1       0          |z
    0       0       0       1          |w

    То есть первая строка умножается на первый столбец
    в этом и смысл преобразования - строки из первого перемножаются на столбцы второго

    а так как умножается фактически второе (столбцы, количество которых ограничено)
    на первое, то имеем:

    MsizeMatr * NsizeMatr = NsizeMatr

    прохождение одного или нескольких векторов через матрицу осуществляется 
    следующим образом:

    m = 
    a       b       c       d
    e       f       g       h
    i       j       k       l
    m       n       o       p

    v = 
    x1      x2      x3      x4
    y1      y2      y3      y4
    z1      z2      z3      z4
    1       1       1       1

    последовательное перемножение колонок V на M дает:

    1ый вектор (столбец результирующей матрицы):

    x1*a+       y1*b+       z1*c+       1*d
    x1*e+       y1*f+       z1*g+       1*h
    x1*i+       y1*j+       z1*k+       1*l
    x1*m+       y1*n+       z1*o+       1*p

    2ой вектор (столбец результирующей матрицы):

    x2*a+       y2*b+       z2*c+       1*d
    x2*e+       y2*f+       z2*g+       1*h
    x2*i+       y2*j+       z2*k+       1*l
    x2*m+       y2*n+       z2*o+       1*p

    иначе говоря результат для M*V формируется так:
    (каждый ряд вычисляется отдельно по сути - за счет всей матрицы abc..nop)

    x1*a+y1*b+z1*c+1*d      x2*a+y2*b+z2*c+1*d      x3*a+y3*b+z3*c+1*d      x4*a+y4*b+z4*c+1*d
    x1*e+y1*f+z1*g+1*h      x2*e+y2*f+z2*g+1*h      x3*e+y3*f+z3*g+1*h      x4*e+y4*f+z4*g+1*h
    x1*i+y1*j+z1*k+1*l      x2*i+y2*j+z2*k+1*l      x3*i+y3*j+z3*k+1*l      x4*i+y4*j+z4*k+1*l
    x1*m+y1*n+z1*o+1*p      x2*m+y2*n+z2*o+1*p      x3*m+y3*n+z3*o+1*p      x4*m+y4*n+z4*o+1*p

    Данное правило применимо и к перемножению матриц
    (можно представить x1y1z1..x4y4z4 как матрицу)

    Отсюда правило: При перемножении матриц 2ая - правая матрица должна всегда быть
    меньше 1ой не наоборот.

    При осуществлении операции перемножения матриц MxN не эквивалентно NxM 
    (если они только ни одинаковые)

    M = 
    A       B
    C       D

    N = 
    x1      x2
    y1      y2

    MxN = 
    x1a+y1b     x2a+y2b
    x1c+y1d     x2c+y2d

    NxM = 
    ax1+cx2     bx1+dx1
    ay1+cy2     by1+dy2

    Главною матричною диагональю назваются такие элементы матрицы в которых
    номер столбца равен номеру строки:
    [00][11][22][nn]

52. МАТЕМАТИЧЕСКОЕ ПРЕДСТАВЛЕНИЕ УМНОЖЕНИЯ МАТРИЦ
-------------------------------------------------

    Rij = (от n)SUM(до k=1) для M(ik) * L(kj)
    
    при:
    i - номер строки
    j - номер столбца
    n - размерность обеих матриц

    При перемножении матриц можно скомбинировать любое количество матричных операций
    при которых 

    MxN - матрица N принимает изменения на себя от матрицы M

    Алгоритм исходя из формулы:

    void mult_m(float mr[4][4], float m1[4][4], float m2[4][4])
    {
        for(int i = 0; i < 4; i++)
        {
            for(int ii = 0; ii < 4; ii++)
            {
                -- получим столбец с m1:
                float m1c1 = m1[0][ii];
                float m1c2 = m1[1][ii];
                float m1c3 = m1[2][ii];
                float m1c4 = m1[3][ii];

                -- получим строку из m2:
                float m2r1 = m2[i][0];
                float m2r2 = m2[i][1];
                float m2r3 = m2[i][2];
                float m2r2 = m2[i][3];

                -- заполним результат столбца:
                mr[i][ii] = m1c1*m2r2 + m1c2*m2r2 + m1c3*m2r3 + m1c4*m2r4;
            }
        }
    }

    при перемножении матриц - сохраняется порядо произведенных преобразований:
    например сначала повернуть влево потом сдвинуть, потом повернуть вправо

    повернуть влево:
    матрицаА

    сдвинуть:
    матрицаБ

    повернуть вправо:
    матрицаВ

    сначала повернуть - потом сдвинуть - потом снова повернуть:
    матрицаА * матрицаБ * матрицаВ = матрица_итоговых_трансформаций

    очень важно соблюдать порядок преобразований,
    так как сдвинуть и потом повернуть, явно не соотвтсвует сначала повернуть, а потом сдвинуть

    проще всего воспринимать:
    строки - это то что изменяет каждую из ячеек
    чтобы изменить ОДИН столбец правой матрицы нужны ВСЕ строки
    левой матрицы.

    левая матрица это предыдущие преобразования в цепочке преобразований
    правая матрица - это или вектор - (итог)
    или последующие преобразования (которые ждут перемножения на вектор)

53. ВЗАИМОСВЯЗЬ МАТРИЦ И СИСТЕМЫ КООРДИНАТ:
-------------------------------------------

    Если представить систему координат с помощью матрицы 4х4:

    m = 
    a   b   c   d
    e   f   g   h
    i   j   k   l
    m   n   o   p

    то направления векторов для каждой из осей следующие:
    x = [aei]
    y = [bfj]
    z = [cgk]

54. МАТРИЦА ИДЕНТИЧНОСТИ:
-------------------------
    
    В матрице идентичности i = j и установлены в 1у,
    остальные элементы == 0

    1   0   0   0
    0   1   0   0
    0   0   1   0
    0   0   0   1
                ...1

55. ТРАНСПОНИРОВАНИЕ МАТРИЦЫ (TRANSPOSE)
----------------------------------------

    Транспонированная матрица это такая матрица, в которой элемент [ij] оригинала
    соответствует [ji] элемента результата.

    Математически это выглядит так:

    M^1[ij] = M[ji]

    Эта операция может быть достигнута лишь для таких матриц, у которых
    M столбцов = N строк.

    например:

    M = 
    1   2
    3   4

    Mtranspose = 
    1   3
    2   4

    Причем если матрица является матрицею вращения, то транспонированная матрица
    будет гарантированно матрицею инверса (!)

56. СЛОЖЕНИЕ/ВЫЧИТАНИЕ МАТРИЦ
-----------------------------

    Данная операция осуществляется через сложение/вычитание M[ij] от N[ij] элемента:

    M = 
    a       b
    c       d

    N = 
    e       f
    g       h

    R = 
    a+e     b+f 
    c+g     d+h

57. ВОЗВЕДЕНИЕ МАТРИЦЫ В СТЕПЕНЬ
--------------------------------

    Для всех степеней матрица должна быть квадратною, т.е. иметь одинаковые ширину и высоту
    
    Обозначают следующие операции:

    M^-1 - инверс к матрице (1/M)
    M^0  - генерирует матрицу идентичности
    M^1  - оставляет матрицу в том же состоянии, что и изначально
    M^2  - производит квадрат операции
    M^3  - производит куб операции

    Возведение матрицы в степень есть умножение матрицы на саму себя заданное количество раз
    (умножение матрицы - это повторение своей операции)

    М^n = M*M ... Mn

    Возведение матрицы идентичности в степень производит матрицу идентичности

    I^n = I

    Алгоритм:

    m - матрица возведенная в степень
    a - результирующая матрица
    / - целочисленное деление 
    * - матричное умножение
    i - степень возведения
    I - матрица идентичности
    % - целочисленный остаток от деления

    a = I;
    while(i>0)
    {
        if(i%2) a = a*m;
        i = i/2;
        m = m*m;
    }

58. СВОЙСТВА ОПЕРАЦИЙ НАД МАТРИЦАМИ:
------------------------------------

    1. Сложение
        1) переместительное свойство:       A+B = B+A
        2) сочетательное свойство:          (A+B)+C = A+(B+C)

    2. Умножение (на число)
        1) Распределительное свойство относительно суммы:
            N*(A+B) = Na + Nb
        2) Сочетательное свойство относительно числового множителя:
            NM(a) = N(Ma)
        3) Расширительное свойство относительно суммы чисел:
            (N+M)a = Na + Ma

    3. Перемножение матриц
        1) Сочетательное свойство:
            A*(B*C) = A*B*C
        2) Распределительное свойство относительно суммы
           матриц:
            (A+B)*C = A*C + B*C или
            A*(B+C) = A*B + A*C
        3) Перестановочное свойство у Е и O матриц 
            при Е (единичной по главной диагонали): А*E = E*A = A
            при O (нулевой матрице): A*O = O*A = O
        4) Отсутствие перестановочного свойства:
            A*B != B*A

59. МАТРИЧНЫЕ ОПРЕДЕЛИТЕЛИ (ДЕТЕРМИНАНТЫ)
-----------------------------------------

    Детерминант - показатель того - имеет ли система уравнений 
    закодированная в матрице ноль, одно, или нескольких решений.

    Детерминанты еще называют определители,
    детерминант 3х3 матрицы называют еще определителем 3го порядка,
    детерминант 4х4 матрицы называют еще определителем 4го порядка и тд.

    Так как матрица по сути является системою уравнений 
    по каждой из её строк для каждого из вектора перемножаемого на неё,
    то есть каждая строка это уравнение - с решением в части 
    вектора, перемножаемом на эту строку.

    Поэтому же - при наличии 0ля нет решений, так как 
    инверсия - дает 1/0 - и очевидно это показатель, 
    что операция невозможна.

    Можно с помощью матрицы представлять например пересечения,
    или инверсные матрицы (обратное действие) для неё можно
    найти такой детерминант.

    Для матриц детерминант это число (float), используемое для того 
    чтобы определить, - имеет ли матрица инверс или нет 
    (при det==0 - инверса нет)

    Для примера рассмотрим матрицу с 1им элементом, m = [1],
    для неё детерминанг это значение единственного элемента.

    m^-1 = [1/m[0]] <- инверс к матрице это обратная величина (reciprocal)
    при det=0, решения нет, так как 1/0 != решение

    Для матрицы идентичности детерминант всегда будет равен 1е.

    Любая матрица с определителем равным 1е называется изотропной.

    Все матрицы вращения имеют определитель 1, следовательно они 
    изотропны.
    (отсюда поиск инверса ведется через транспонирование матрицы)

    M = 
    a           b
    c           d
    =
    cosx        -sinx
    sinx        cosx

    D = AD-BC           <=>
    cosx^2 - (-sinx^2)  <=>
    cosx^2 + sinx^2 = 1

    соответственно при любом X : D = 1

60. РАСЧЕТ ДЕТЕРМИНАНТА:
------------------------

    для 2х2 матрицы:

    М = 
    a       b
    c       d

    Det = AD - BC

    По правилу Крамера для нахождения детерминанта:

    submat..  - детерминант субматрицы

    det = M00 * submat(M^000) * -1 + M01 * submatM^101 * -1
    <=>
    M00 * M11 * 1 + M01 * M10 * -1
    <=>
    AD + BC * -1
    <=>
    AD - BC

    Для 3х3 матрицы:

    М = 
    a       b       c
    d       e       f
    g       h       i

    Det = A * (EI - HF) - B * (DI-GF) + C * (DH - GE)

    Для 4х4 матрицы детерминант считается так:

    float m4_det(MATRIX4 MR)
    {
        float det, result = 0, i = 1;
        MATRIX3 msub3, int n;

        float(n=0; n<4; n++, i*= 01)
        {
            m4_submat(mr, msub3, 0, n);
            det = m3_det(msub3);
            result += mr[n]*det*i;
        }
        return result;
    }

    При формуле нахождения субматрицы:

    void m4_submat(MATRIX4 mr, MATRIX3 mb, int i, int j)
    {
        int di, dj, si, sj;

        -- формируем 3х3 матрицу
        for(di=0; di<3; di++)
        {
            for(dj=0; dj<3; dj++)
            {
                -- размещаем 3х3 элемент (destination) к 4х4 элементу (source)
                si = di + ( (di >= i) ? 1 : 0  );
                sj = dj + ( (dj >= j) ? 1 : 0  )l

                -- копируем элемент
                mb[di*3 + dj] = mr[si*4 + sj];
            }
        }
    }

61. ПОИСК ДЕТЕРМИНАНТА МАТРИЦЫ ВРУЧНУЮ
--------------------------------------

    При 
    a11     a12     a13
    a21     a22     a23
    a31     a32     a33

    det3x3 = 
    a11*a22*a33 + a12*a23*a31 + a13*a21*a32 - 
    a11*a23*a32 - a12*a21*a33 - a13*a22*a31

    Для 3х3 матриц детерминанг ищется через субматрицы и 
    их детерминанты.

    Алгоритм расчета детерминанта:

    det4x4 = 

                        *---
                        |□□□
                        |□□□
                        |□□□

    m[0][0] * det3x3(
                        m[1][1], m[2][1], m[3][1],
                        m[1][2], m[2][2], m[3][2],
                        m[1][3], m[2][3], m[3][3]
                    )
                
                        -*--
                        □|□□
                        □|□□
                        □|□□

    -m[0][1] * det3x3(
                        m[1][0], m[2][0], m[3][0],
                        m[1][2], m[2][2], m[3][2],
                        m[1][3], m[2][3], m[3][3]

                    )
                        --*-
                        □□|□
                        □□|□
                        □□|□

    +m[0][2] * det3x3(
                        m[1][0], m[2][0], m[3][0],
                        m[1][1], m[2][1], m[3][1],
                        m[1][3], m[2][3], m[3][3]
                    )
                        ---*
                        □□□|
                        □□□|
                        □□□|

    -m[0][3] * det3x3(
                        m[1][0], m[2][0], m[3][0],
                        m[1][1], m[2][1], m[3][1],
                        m[1][2], m[2][2], m[3][2],
                    )

    При det3x3 рассчитываемом следующим образом:

    a1  b1  c1   +  *--  -   -*-   +   --*
    a2  b2  c2      |□□      □|□       □□|
    a3  b3  c3      |□□      □|□       □□|


    float det3x3(   a1,a2,a3,
                    b1,b2,b3,
                    c1,c2,c3)
    {
        return 
                  a1 * det2x2(b2,b3, c2,c3)
                - b1 * det2x2(a2,a3, c2,c3)
                + c1 * det2x2(a2,a3, b2,b3);
    }

    рассчет det2x2: 

        a   b     =     *-    -     -*
        c   d           |□          □|

    float det2x2(a,b,c,d) {return a*d - b*c;}

62. РАСЧЕТ ИНВЕРСИОННОЙ МАТРИЦЫ:
--------------------------------

    Для 2х2 матрицы:

    м = 
    a   b
    c   d

    m^-1 = 
    1 / det * 
    d   -c
    -b  a

    Инверсия рассчитывается следующим образом:

    M00^-1 = detsubmat00 * -1^(0+0)        <=>     M00^-1 = M11 *  1   <=> D
    M01^-1 = detsubmat10 * -1^(1+0)        <=>     M01^-1 = M10 * -1   <=> C * -1
    M10^-1 = detsubmat01 * -1^(0+1)        <=>     M10^-1 = M01 * -1   <=> B * -1
    M11^-1 = detsubmat11 * -1^(1+1)        <=>     M11^-1 = M00 *  1   <=> A

    Для 3х3 матрицы:
    расчетный элемент в матрице (вроде EI-FH) называется adjoint для оригинальной ячейки (М00^1)

    M^-1 = 
        1 / det * 
        EI-FH               -(BI-HC)            BF-EC
        -(DI-FG)            AI-CG               -(AF-DC)
        DH-GE               -(AH-GB)            AE-BD

        <=>

        M/det

    a   b   c
    d   e   f
    g   h   i

    Алгоритм:
    (каждая ячейка матрицы (МА) делиться на детерминант)

    int m3_inverse(MATRIX3 mr, MATRIX3 ma)
    {
        float det = m3_det(ma);

        if(fabs(det) < 0.0005) return 0;

        --          ----------------adjoint----------------
        mr[0]   =   (ma[4]*ma[8]        -       ma[5]*ma[7]) / det;
        mr[1]   =  -(ma[1]*ma[8]        -       ma[7]*ma[2]) / det;
        mr[2]   =   (ma[1]*ma[5]        -       ma[4]*ma[2]) / det;

        mr[3]   =  -(ma[3]*ma[8]        -       ma[5]*ma[6]) / det;
        mr[4]   =   (ma[0]*ma[8]        -       ma[6]*ma[2]) / det;
        mr[5]   =  -(ma[0]*ma[5]        -       ma[3]*ma[2]  / det;
        
        mr[6]   =   (ma[3]*ma[7]        -       ma[6]*ma[4]) / det;
        mr[7]   =  -(ma[0]*ma[7]        -       ma[6]*ma[1]) / det;
        mr[8]   =   (ma[0]*ma[4]        -       ma[1]*ma[3]) / det;

        return 1;
    }

    Для 4х4 матрицы:

    1. ищем детерминант всей матрицы
    2. для (ij) результата
        а) ищем знак:       (1-( (i+j)%2 ) * 2)
        б) Rij = (m3_det * sign) / det

    Код:

    int m4_inverse(MATRIX4 mr, MATRIX4 ma)
    {
        float mdet = m4_det(ma);

        MATRIX3 mtemp;

        if(fabs(mdet) < 0.0005) return 0;

        for(int i = 0; i < 4; i++)
        {
            for(int j = 0; j < 4; j++)
            {
                int sign = 1 - ((i+j)%2)*2;
                m4_submat(ma, mtemp, i,j);
                mr[i+j*4] = (m3_det(temp), sign) / mdet;
            }
        }
        return 1;
    }

63. ПЕРЕСЕЧЕНИЕ МЕЖДУ 3МЯ ПЛОСКОСТЯМИ
-------------------------------------

    Так как матрицы позволяют использовать себя
    для решения системы уравнений
    а пересечение с плоскостью - это уравнение 
    его можно разместить в матрице, как факт получаем:

    формула пересечения 3х плоскостей:

    P*N1-K1 = 0 }
    P*N2-K2 = 0 } ищем точку P (XYZ)
    P*N3-K3 = 0 }

    n1x     n1y     n1z     -k1             PX           0
    n2x     n2y     n2z     -k2     x       PY       =   0
    n3x     n3y     n3z     -k3             PZ           0
    0       0       0       1               1            1

    преобразуем данное уравнение для нахождения <xyz> нашей точки

    PX            |  n1x    n1y     n1z     -k1 |^-1        0
    PY      =     |  n2x    n2y     n2z     -k2 |       x   0
    PZ            |  n3x    n3y     n3z     -k3 |           0
    1             |  0      0       0        1  |           1

    После расчета инверсной матрицы четвертая колонка будет содержать точку 
    пересечения, причем если мы не сможем найти инверсной матрицы, - значит
    как минимум две плоскости параллельны и не имеется точки пересечения
    (исходя из решения подобных уравнений)

    Можно упростить выражение, используя 3х3 матрицу:

    PX          n1x     n1y     n1z             k1
    PY      =   n2x     n2y     n2z     x       k2
    PZ          n3x     n3y     n3z             k3
    
64. ПЕРЕСЕЧЕНИЕ МЕЖДУ 2МЯ ПЛОСКОСТЯМИ
-------------------------------------

    По определению линия пересечения между 2мя плоскостями это 
    перпендикуляр к каждой из нормалей плоскостей, т.е.:

    DIR(пересечение) = N1 x N2          (где "х" это CrossProduct)

    Теперь можно задать 3ю плоскость (используя Dir), и используя её 
    рассчитать Org для прямой пересечения (К3 не имеет значения, т.к. 
    линия прямая):

    orgX                n1x     n1y     n1z     0               K1
    orgY      =         n2x     n2y     n2z     0       x       K2
    orgZ                dirX    dirY    dirZ    0               0
    1                   0       0       0       1               1

65. ТРАНСЛИРОВАНИЕ С ИСПОЛЬЗОВАНИЕМ МАТРИЦ
------------------------------------------

    Достигается через заданные значения в 4ой колонке матрицы:

    1   0   0   tx              x           x*1+ y*0+ z*0 + 1*tx = x+tx
    0   1   0   ty      x       y     =     ..
    0   0   1   tz              z
    0   0   0   1               1           w=1

66. МАСШТАБИРОВАНИЕ С ИСПОЛЬЗОВАНИЕМ МАТРИЦ
-------------------------------------------
 
           x    |    x  <-- отмасштабировано
            \   |   /
             x  |  x   <-- было
        ________|________
             x  |  x
            /   |   \
           x    |    x


    SX      0       0       0               X       X*SX + Y*0 + Z*0 + 1*0
    0       SY      0       0       x       Y  =    ..
    0       0       SZ      0               Z
    0       0       0       1               1

    С использованием мастабирования можно получить отражение:

                |  
                |  
         (*)--------->(*)
        ________|________
                |   
                |    
                |     

    -1      0       0       0               X    (x*-1) + (Y*0) + (Z*0) + (1*0) = -X
    0       1       0       0       x       Y =  ..
    0       0       1       0               Z
    0       0       0       1               1


67. ВРАЩЕНИЕ С ИСПОЛЬЗОВАНИЕМ МАТРИЦ
------------------------------------

    Вращение достигается с использованием теоремы Пифагора:

    вокруг Х:

    1           0           0           0               x1 = x
    0           cos(th)     -sin(th)    0               y1 = cos(th)*y - sin(th)*z
    0           sin(th)     cos(th)     0               z1 = sin(th)*y + cos(th)*z
    0           0           0           1

    вокруг Y:

    cos(th)     0           sin(th)     0               x1 = cos(th)*x + sin(th)*z
    0           1           0           0               y1 = y
    -sin(th)    0           cos(th)     0               z1 = -sin(th)*x + cos(th)*z
    0           0           0           1

    вокруг Z:

    cos(th)     -sin(th)    0           0               x1 = cos(th)*x + (-sin(th)*y)
    sin(th)     cos(th)     0           0               y1 = sin(th)*x + cos(th)*y
    0           0           1           0               z1 = z
    0           0           0           1

68. ЭФФЕКТ ОТРАЖЕНИЯ С ИСПОЛЬЗОВАНИЕМ МАТРИЦ
--------------------------------------------

    Отражение предсталяет собою сдвиг всех точек относительно воображаемой 
    плоскости в 3Д пространстве.

            |
            | отражение в сторону нормали 
    (*)----->----->(*)
            |
            |

    Для полуения эффекта отражения нам потребуется:

    1. расчитать расстояние от плоскости до точки
    2. сдвинуть точку на растояние до плоскости, умножив её на 2,
       в направлении, противоположном нормали плоскости

    Уравнение отражения:

    P1 = P - (2*dist) * normal(plane)

    Заменяем dist:
    P1 = P - 2(P*normal+K) * normal

    Рассчитаем dot для P*normal        (// K = -K, - используется ориг. алгоритм)
    P1 = P - 2(Px*Nx + Py*Ny + Pz*Nz + K) * normal

    Расширенное уравнение для каждого элемента в P (при P-(значение))

    P1x = px - 2*px*nx*nx + 2*py*ny*nx + 2*pz*nz*nx + 2*K*nx
    P1y = py - 2*px*nx*ny + 2*py*ny*ny + 2*pz*nz*ny + 2*K*ny
    P1z = pz - 2*px*nx*nz + 2*py*ny*nz + 2*pz*nz*nz + 2*K*nz

    Разместим данное уравнение в матрице:

    1-2*nx*nx           -2*nx*ny        -2*nx*nz        +2*nx*K
    -1*ny*nx            1-2*ny*ny       -2*ny*nz        +2*ny*K
    -2*nz*nx            -2*nz*ny        1-2*nz*nz       +2*nz*K
    0                   0               0               1

    В этой матрице подобны:

    m[0][1] == m[1][0]
    m[0][2] == m[2][0]
    m[1][2] == m[2][1]

69. РЕШЕНИЕ ПОДОБНЫЙ УРАВНЕНИЙ С ИСПОЛЬЗОВАНИЕМ МАТРИЦ
------------------------------------------------------

    При:
    
    a*x + b*y + c*z  + d = 0
    e*x + f*y + g*z  + h = 0
    i*x + j*y + k*z  + l = 0

                                                              -1
    a   b   c   d       x       0               a   b   c   d       0       x
    e   f   g   h   x   y  =    0       <=>     e   f   g   h   x   0   =   y
    i   j   k   l       z       0               i   j   k   l       0       z
    m   n   o   p       1       1               m   n   o   p       1       1

    6*2 = 12                                    (1/6)*12                = 12/6 = 2

    Уравнения получат следующий вид:

    x = A*0 + B*0 + C*0 + D*1 = D
    y = E*0 + F*0 + G*0 + H*1 = H
    z = I*0 + J*0 + K*0 + L*1 = L

    т.е. решением является 4я колонка в инверсной матрице.

    При неудаче создания инверсной матрицы мы знаем, что уравнение не имеет
    решения (или имеет их бесконечное количество).
    
70. СВЯЗЬ ИЗМЕНЕНИЯ РАЗМЕРНОСТИ (SCALING) И НОРМАЛЕЙ
----------------------------------------------------

    Следует опасаться использования матриц типа:

    1       0       0
    0       1       0
    0       0       0.5

    с поверхностями, имеющими заданными нормалями (особенно если 
    по этим нормалям что то строиться, например освещение),
    так как у нормалей исчезнет unit.

71. ПРЕДСТАВЛЕНИЕ УГЛОВ ЭЙЛЕРА
------------------------------

    Углы Эйлера представляют собою 3 float значения, каждое из которых
    задает вращение вокруг x,y,z осей и представленные в виде вектора, где значения каждой 
    из осей представляет вращение вокруг этой оси:

    |RotByX     RotByY      RotByZ|

72. YAW, PITCH, ROLL
--------------------

    YPR - заимствованные из авиации термины, представляющие объектно ориентированное 
    вращение:

    ⢀⢀⢀⣖⠲⡀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀Y⢀⢸⠉⡇⢀⢀⢀⢀⢀⢀⢀
    ⢀⢀⢀⠸⡆⠹⡀⣠⢤⡄⢀⢀⢀⢀⢀⢀⢀⢀|⢀⡏⢀⡧⢤⡄⢀⢀⢀⢀⢀
    ⢀⢀⢀⢀⡧⢄⣹⣅⣜⡀⢀⢀⢀⢀⢀⢀⢀⢀|⢸⠁⢀⢹⠚⠃⢀⢀⢀⢀⢀
    ⢀⣀⠴⢒⣉⡹⣶⣤⣀⡉⠉⠒⠒⠒⠤⠤⣀⣀|⠇⢀⢀⢸⠠⣄⢀⢀⢀⢀⢀
    ⢀⠈⠉⠁⢀⢀⢀⠉⠒⠯⣟⣲⠦⣤⣀⡀⢀⢀|⠉⠉⠉⠛⠒⠻⢥⣀⢀⢀⢀
    ⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⠈⠙⣲⡬⠭⠿⢷|⣤⢄⣀⢀⢀⠚⠛⠛⠓⢦⡀
    ⢀⢀⢀⢀⢀⢀⢀⢀⣀⠤⠴⠚⠉⠁⢀⢀⢀⢀⣀⣉⡽⣕⣯⡉⠉⠉⠑⢒⣒⡾
    ⢀⢀⣀⡠⠴⠒⠉⠉⢀⢀⣀⣀⠤⡤⢶⣶⣋⠉⠉⢀⢀⢀⠈⠉⠉⠉⠉⠉⠁⢀-
    ⣖⣉⣁⣠⠤⠶⡶⡶⢍⡉⢀⢀⢀⠙⠒⠯⠜⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀   -
    ⢀⠁⢀⢀⢀⢀⠑⢦⣯⠇⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀⢀      --> Z
         |
       |
     X

     Yaw - вокруг Y
     Pitch - вокруг X
     Roll - вокруг Z

73. СОЗДАНИЕ МАТРИЦЫ ИЗ УГЛОВ ЭЙЛЕРА
-------------------------------------

    Неоптимизированный метод, представляющий собою общий алгоритм:

    m3_rotX(matX, vec->angleX);
    m3_rotY(matY, vec->angleY);
    m3_rotZ(matZ, vec->angleZ);

    m3_mult(mr, matX, matY, matZ);

    Оптимизированный метод (при перемножении матриц отброшены пустые операции):

    а)  при 
        A и B - cos и sin в Xrot матрице
        С и D - cos и sin в Yrot матрице
        E и F - cos и sin в Zrot матрице

        Xrot =  
            1  0  0
            0  A -B
            0  B  A

        Yrot = 
            C  0  D
            0  1  0
            -D 0  C

        Zrot = 
            E -F  0
            F  E  0
            0  0  1

    b) Оптимизируем вывод:

    Mresult = Xrot * Yrot * Zrot = 

    CE          -CF          D
    BDE+AF      -BDF+AE      -BC
    -ADE+BF     ADF+BE       AC

    код решения:

    A = cos(angle_x)            B = sin(angle_x)            AD = A*D
    C = cos(angle_y)            D = sin(angle_y)            BD = B*D
    E = cos(angle_z)            F = sin(angle_z)

    m[0] = C*E                  m[1] = -C*F                 m[2] = D
    m[4] = BD*E+A*F             m[5] = -BD*F+A*E            m[6] = -B*C
    m[8] = -AD*E+B*F            m[9] = AD*F+B*E             m[10] = A*C

    m[3] = m[7] = m[11] = m[12] = m[13] = m[14] = 0
    m[15] = 1

74. ПРЕОБРАЗОВАНИЕ МАТРИЦЫ ВРАЩЕНИЯ В УГЛЫ ЭЙЛЕРА (+GIMBALLLOCK ПРОВЕРКА)
-------------------------------------------------------------------------

    Алгоритм:

    angle_y = d = asin(m[2])        // y угол
              c = cos(angle_y)
    angle *= RADIANS

    проверка на GimballLock:
    
    if(fabs(c) > 0.005)             // все нормально, нет GimballLock
    {
        trx = m[10] / c
        try = -m[6] / c
        angle_x = atan2(try,trx)*radians   // х угол в градусах

        trx = m[0] / c
        try = -m[1] / c
        angle_z = atan2(try,trx)*RADIANS   // z угол в градусах
    }
    else
    {
        Есть GimballLock:

        angle_x = 0                 // жертвуем X осью
        trx = m[5]
        try = m[4]
        angle_z = atan2(try,trx)*RADIUS
    }

    возвращаем только положительные углы:

    if(angle_x < 0) angle_x += 360
    if(angle_y < 0) angle_y += 360
    if(angle_z < 0) angle_z += 360

75. ОПТИМИЗИРОВАННЫЙ ВАРИАНТ ПОЛУЧЕНИЯ МАТРИЦЫ ВРАЩЕНИЯ ИЗ ПРОИЗВОЛЬНОЙ ОСИ И УГЛА
----------------------------------------------------------------------------------

    phi - угол, UVW - векторное представление оси

    rcos = cos(phi)
    rsin = sin(phi)

    m[0][0] = rcos + U*U*(1-rcos)
    m[1][0] = W*rsin + V*U*(1-rcos)
    m[2][0] = -V*rsin + W*U*(1-rcos)

    m[0][1] = -W*rsin + U*V*(1-rcos)
    m[1][1] = rcos + V*V*(1-rcos)
    m[2][1] = U*rsin + W*V*(1-rcos)

    m[0][2] = V*rsin + U*W*(1-rcos)
    m[1][2] = -U*rsin + V*W*(1-rcos)
    m[2][2] = rcos + W*W*(1-rcos)

76. РАЗМЕЩЕНИЕ ОДНОГО ВЕКТОРА К ДРУГОМУ С ИСПОЛЬЗОВАНИЕМ МАТРИЦ
---------------------------------------------------------------

    Для применения требуется использовать угол между векторами, находимый 
    через Dot между 2мя векторами и ось полученную через Cross между этими 
    векторами.

           V2
           |   
           |           
           |________ V1
            \ 
             \
              \ CrossV1V2Axis

    Vaxis = Vstart x Vfin
    Vangle = acos(Vstart*Vfin)                 (Vangle = cos^-1(Vstart*Vfin))

77. ПРЕОБРАЗОВАНИЕ ИЗ ОДНОЙ СИСТЕМЫ КООРДИНАТ В ДРУГУЮ (СИСТЕМЫ ЗАДАНЫ МАТРИЦАМИ)
---------------------------------------------------------------------------------

    Преобразование по сути,- это проецирование одного на другого через dot продукт
    Матрицы лучше всего подходят для преобразований - так как они 
    фактически прогоняя через себя вектора создают dot продукт вычисления.

    Базовый алгоритм:

    Mfinal = Mrot * Morg

    где:
        Mfinal - 1я матрица
        Mrot - искомая матрица
        Morg - 2я матрица

    преобразуем формулу для поиска Mrot 
        (6 = 3*2)
        (3 = 6/2)

    При преобразовании из Morg в Mfinal

    Mrot 
        = Mfinal / Morg
        = Mfinal * (1/Morg)
        = Mfinal * Morg^-1

    Данная матрица часто используется в средах моделирования, причем единожды
    расчитав такую матрицу, её можно будет преобразовать в кватернион.

78. МАТРИЦА СКОСА (SCEW)
------------------------

    Всего существует 6ть возможных скосов (сдвигов по осям)
    
    При скосе XY =>

    1     0     0     0         x       x1 = x
    Sxy   1     0     0    x    y  =    y1 = x*Sxy + y
    0     0     1     0         z       z1 = z
    0     0     0     1         1       1

    Остальные скосы (с указанием направления скоса):

    x->y
    x->z
    y->x
    y->z
    z->x
    z->y

    Матрица со всеми скосами:

    Mscew = 
        1       Syz     Szx     0
        Sxy     1       Szy     0
        Syz     Syz     1       0
        0       0       0       1

79. ИНТЕРПОЛЯЦИЯ МЕЖДУ МАТРИЦАМИ
--------------------------------

    Интерполяция между матрицами ищеться как интерполяция между столбцами
    матриц (столбцы представляются как вектора)

    Для векторов 

        Vr = Vs + t * (Vf - Vs)

    x1  x2      x01 x02         x1+t*(x01-x1)   x2+t*(x02-x2)
    y1  y2  и   y01 y02 =>      y1+t*(y01-y1)   y2+t*(y02-y2)
    z1  z2      z01 z02         z1+t*(z01-z1)   z2+t*(z02-z2)

80. СВОЙСТВА ОПРЕДЕЛИТЕЛЕЙ МАТРИЦ
---------------------------------

    Если квадратная матрица Аt является транспонированной матрицею А,
    то их определители совпадают |At| = |A|, т.е. определитель не меняется если
    заменить его строки столбцами и наоборот

    a11 a12 a13             a11 a21 a31
    a21 a22 a23     =       a12 a22 a32
    a31 a32 a33             a13 a23 a33

    При перестановке 2х строк или столбцов определитель меняет свой знак 
    на противоположный, сохраняя абсолютную величину:

    a11 a12 =   - | a21 a22 |
    a21 a22       | a11 a12 |

    Если определитель имеет 2 одинаковых строки или столбца, то он равен 0

81. АЛГЕБРАИЧЕСКИЕ ДОПОЛНЕНИЯ И МИНОРЫ
--------------------------------------

    Пусть имеется определитель 3го порядка:

    d = 
    a11 a12 a13
    a21 a22 a23
    a31 a32 a33

    Минором соответствующим элементу Aij определителя 3го порядка называется 
    определитель 2го порядка, полученный из данного вычеркиванием строки и столбца, на 
    пересечении которых стоит данный элемент, т.е. i-ой строки и j-ого столбца, миноры,
    соответствующие данному элементу Aij бдут обозначать Mij

    Например минором M12, соответствующему элементу A12, будет определитель:

    M12 = 
    a21 23
    a31 a33

    Таким образом формула, определяющая определитель 3го порядка, показывает, что
    этот определитель равен сумме произведений элементов 1ой строки на 
    соответствующие им миноры, при этом минор, соответствующий 
    элементу A12, береться со знаком "-".

    d = A11*M11 - A12*M12 + A13*M13

    Аналогично можно вывести миноры 2го и высших порядков.

    Алгебраическим дополнением элемента Аij называется его минор Mij,
    умноженный на (-1)^(i+j)

    Из определения получаем, что связь между алгебраическим дополнением элемента 
    и его минором выражается равенством:

    Aij = Mij * (-1)^(i+j)

    Например:

    A11 = M11 * (-1)^(1+1) = M11
    A32 = M32 * (-1)^(3+2) = -M32

    Например для:

    0   -1  1
    3   2   -2
    4   -1  2

    найдем А13, А21, А32

    А13 = 
    |2   3 |  = -2 - 12 = -14
    |4   -1| 
    

    А32 = 
    - | 0 1  | = 2
      | 2 -2 |

    A21 = 
    | -1 1 | = 2-1 = 1
    | -1 2 |

    Используя алгебраическое дополнение формулу поиска определителя 
    можно переписать следующим образом:

    d = 
        a11 * (-1)^(1+1) * M11 
        + 
        a12 * (-1)^(1+2) * M12 
        + 
        a13 * (-1)^(1+3) * M13 = a11*A11 + a12*A12 + a13*A13

    Аналогично этой формуле можно получить разложение определителя
    по элемента любой строки или столбца.

    Например, разложение определителя по элементам 2ой строки можно
    получить следующим образом (согласно свойству 2 определителя имеем):

    d = 
      | a11 a12 a13 |
      | a21 a22 a23 |
      | a31 a32 a33 |
      = 
      | a21 a22 a23 |
    - | a11 a12 a13 |
      | a31 a32 a33 |

    Разложим полученный определитель по элементам 1ой строки:

    | a21 a22 a23 |         | a12 a13 |         | a11 a13 |   | a11 a12 |
    | a11 a12 a13 | = a21 * | a32 a33 | - a22 * | a31 a33 | + | a31 a32 |
    | a31 a32 a33 |

    отсюда:

        | a11 a12 a13 |
    d = | a21 a22 a23 | = -a21*M21 + a22*M22 - a23*M23, т.к.
        | a31 a32 a33 |

    определители второго порядка есть миноры элементов a21, a22, a23
    таким образом:

    d = a21*A21 + a22*A22 + a23*A23, т.е. мы получили
    расположение определителя по элементам 2ой строки.

    Аналогично можно получить расположение определителя по элементам 
    3ей строки используя 1ое свойство определителей (о транспонировании),
    можно сказать, что аналогичные разложения справедливы и при разложении
    по элементам столбцов.

    Таким образом, справедлива следующая теорема:

    Теорема (о расположении определителя по заданой строке или столбцу)

    Определитель равен сумме произведений элементов какой либо его строки 
    (или столбца) на их алгебраические дополнения.

    Все вышесказанное справедливо и для определителей любого более 
    высокого порядка.

    1) Вычислим определитель 3х3, раскладывая по элементам 2го столбца:

    |  2  1  -2 |               | -1  3 |               |  2  -2 |                |  2  -2  |
    | -1  0   3 | =  1*(-1)^3 * | -3  1 |  + 0*(-1)^4 * | -3   1 | + 4 * (-1)^4 * | -1   3  | = 
    | -3  4   1 |      
                 
                  = -(-1+9) - 4*(6-2) = -8 - 16 = -24

    2. Вычислим определитель используя его свойства. Прежде чем раскладывать
    определитель по элементам какой либо стороны, сводя к определителям 3го порядка,
    преобразуем его, используя свойство 7, сделав в какой либо строке или столбце 
    все элементы, кроме одного, равными 0
    (в примере удобно рассмотреть 4ый столбец и 4ю строку):

    |  4    1    1    0  |      
    | -2   -1    0    1  |   
    | -2    1   -2   -1  |
    |  0    1   -1    0  |

    = (по свойству 7 определителей)

    |  4    1    1   *0* |      
    | -4    0   -2   *0* |                     | 4  1  1 |
    | -2****1***-2***-1* |  =  -1*(-1)^(3+4) * |-4  0 -2 | = 
    |  0    1   -1   *0* |                     | 0  1 -1 |

    = 4 * | 0  -2 | - 1* | -4  -2 | + 1 * | -4  0 | = 8-4-4 = 0
          | 1  -1 |      |  0  -1 |       |  0  1 |

82. МАТЕМАТИЧЕСКИЙ РАСЧЕТ ОБРАТНОЙ МАТРИЦЫ
------------------------------------------

    Понятие обратной матрицы существует только для квадратных матриц.
    Если А является квадратною матрицею, то обратная матрица к ней называется матрица
    обозначаемая как A^(-1) и удовлетворяющая уравнению:

    A * A^(-1) = E = A^(-1) * A

    Определение вводится по аналогии с умножением чисел,
    только порядок матриц надо соблюдать, иначе вычисления будут не корректными.

    Справедлива следующая теорема:

    Для того чтобы квадратная матрица имела обратную, необходимо и достаточно,
    чтобы её определитель был отличен от нуля.

    Чтобы найти обратную матрицу нужно:
    1. найти определитель матрицы А
    2. найти алгебраические дополнения Aij всех элементов матрицы А и составить
       матрицу А^1, элементами которой являются числа Aij
    3. Найти матрицу, транспонированную матрице A^1 и умножить её на (1/|A|)
       это и бедет:
                        A^(-1) = ( 1 / |A| ) * (A^1)^T

    Аналогично для матриц 2го порядка, обратной будет матрица:

    A^(-1) = (1 / |A|) * | A11 A21 |
                         | A12 A22 |

    Примеры:

    Найти обратную матрицу к: 

    A = | 1  -1 |  где |A| = 2 
        | 0   2 |

    найти Аij: 
    A11 = 2
    A12 = 0
    A21 = 1
    A22 = 1

    A^1 = | 2  0 |
          | 1  1 |

    1/A*A^1 = |  1    0   |
              |  1/2  1/2 |

    A^(-1) = 1 / |A| * (A^1)^T = | 1  1/2 |
                                 | 0  1/2 |

    Проверка 

    А^1*A = 

    | 1  1/2 |   *  | 1   -1 |  =   | 1   0 |  =   E
    | 0  1/2 |      | 0    2 |      | 0   1 |

    аналогично:
    A*A^-1 = E

83. ИЗОТРОПНЫЕ И АНИЗОТРОПНЫЕ МАТРИЦЫ
-------------------------------------

    Изотропными матрицами считаются такие матрицы у которых сумма квадратов 
    всех 3х строк или столбцов больше 1цы.

    Маторицы с иными показателями называют анизотропными.

84. ОПРЕДЕЛЕНИЕ КВАТЕРНИОНА
---------------------------

    Задается как 4value вектор |xyzw|, что представляет собою |xyz| ось задающую
    вращение и |w| угол вращения.

    Задание кватерниона представляет собою объединение матриц врещания вместе.

    Т.к. ось вращения определена как Unit направляющий вектор, он может быть
    расчитан через векторную математику или из сферических координат.

    Кватернионы представляют отличную возможность для интерполяции, 
    представляя такое вращение.

    При расчете итогового вращения кватернион придется преобразовывать
    все равно в матрицу.

85. РАСЧЕТ ИНВЕРСА К КВАТЕРНИОНУ
--------------------------------

    Под инверсов понимается сопряжение кватернион (conjugate), если кватернион
    нормализован (или это Unit кватернион)

    Во всех остальных случаях длина инверса = 1/|q|

    Расчет conjugate есть негативирование векторной части кватерниона:

    Qr = |Qr.scalar, -Qr.vector|

    void quaternion_conjugate(Quat* qr, Quat* qa)
    {
        qr->qw =  qa->qw;
        qr->qx = -qa->qx;
        qr->qy = -qa->qy;
        qr->qz = -qa->qz;
    }

86. ДЛИНА КВАТЕРНИОНА
---------------------

    Вычисляется как и длина вектора в 3Д, но с 4мя значениями:

    |Qr| = sqrt(Qr^2)        - в оригинале умножается кватернион на conjugate

    float magnitude_quat(Quat* q)
    {
        return sqrt(
            q[w]*q[w] + q[x]*q[x] + q[y]*q[y] + q[z]*q[z]
        );
    }

    кватернион, также как и вектор, может быть нормализован.

        Qunit = Qr / length(Qr)

    В дополнение нормализуется скалярная часть.

87. ПЕРЕМНОЖЕНИЕ КВАТЕРНИОНОВ
-----------------------------

    Также как и при перемножении матриц, - перемножение 
    кватернионов позволяет получить объединенное вращение:

        Qr = q1 * q2

    достигается следующим образом:

        Qr = q1 * q2 = 
            <
            w1*w2 - v1*v2
            ,
            w1*v2+w2*v1 + v1 x v2
            >

    где:
            v1 - <xyz> от Q1
            w1 - (w)   от Q1
            v1 - <xyz> от Q2
            w2 - (w)   от Q2

    то есть:

    Qr = 
        <
            Q1[w]*Q2[w] - Dot(Q1.vector, Q2.vector),                    <- scalar
            Q2.vector*Q2.vector*Q2[w] + Cross(Q1.vector, Q2.vector)     <- vector
        >

    Алгоритм:

    void quaternion_multiply(Quat* qr, Quat* qa, Quat* qb)
    {
        V3 va, vb, vc;
        qr->scalar = qa->scalar * qb->scalar - v3_dot(&qa->vector, &qb->vector);
        v3_cross(&va, &qa->vector, &qb->vector);
        v3_scalef(&vb, &qa->vector, &qb->vector);
        v3_scalef(&vc, &qa->vector, &qb->vector);
        v3_add(&va, &va, &vb);
        v3_add(&qr->vector, &va, &vc);
        quaternion_normalize(qr);
    }

    оптимизированный алгоритм:

    w = w1*w2 - x1*x2 - y1*y2 - z1*z2
    x = w1*x2 + x1*w2 + y1*z2 - z1*y2
    y = w1*y2 + y1*w2 + z1*x2 - x1*z2
    z = w1*z2 + z1*w2 + x1*y2 - y1*x2

88. ПРЕОБРАЗОВАНИЕ КВАТЕРНИОНА В МАТРИЦУ ВРАЩЕНИЯ
-------------------------------------------------

    M1 =                                                        OpenGL порядок:
    1-(2y^2+2z^2)   2xy+2zw         2xz-2yw         0           0   4   8   12
    2xy-2zw         1-(2x^2+2z^2)   2zy+2xw         0           1   5   9   13
    2xz+2yw         2yz-2xw         1-(2x^2+2y^2)   0           2   6   10  14
    0               0               0               1           3   7   11  15

    M2 =                                                        OpenGL порядок:
    1-(2y^2+2z^2)   2xy-2zw         2xz+2yw         0           0   1   2   3
    2xy+2zw         1-(zx^2+2z^2)   2yz-2xw         0           4   5   6   7
    2xz-2yw         2zy+2xw         1-(2x^2+2y^2)   0           8   9   10  11
    0               0               0               1           12  13  14  15

    По правилу о транспонировании матриц вращения, при OpenGL (-)angle вращения, 
    при нормально (+)angle вращения, т.к. М1, есть инверс М2

    Обычно используется М2

    Алгоритм для получения М1 (оптимизированный)

    xx = x*x
    xy = x*y
    xz = x*z
    xw = x*w
    yy = y*y
    yz = y*z
    yw = y*w
    zz = z*z
    zw = z*w

    m[0] = 1-2*(yy+zz);     m[1] = 2*(xy-zw);       m[2] = 2*(xz+yw);
    m[4] = 2*(xy+zw);       m[5] = 1-2*(xx+zz);     m[6] = 2*(yz-xw);
    m[8] = 2*(xz-yw);       m[9] = 2*(yz+xw);       m[10]= 1-2*(xx+yy);

    m[3] = m[7] = m[11] = m[12] = m[13] = m[14] = 0;
    m[15] = 1;

89. ПРЕОБРАЗОВАНИЕ МАТРИЦЫ ВРАЩЕНИЯ В КВАТЕРНИОН
------------------------------------------------

    1. Расчитывается trace матрицы T из вразения

        T   = 4-4x^2 - 4y^2 - 4z^2 
            = 4*(1-x^2 - y^2 - z^2)
            = 1 + m[0] + m[5] + m[10]

    2. Если T > 0, тогда производится полный расчет (тестируем T > 0.0000000001 
       для прерывания больших затрат

        S = sqrt(T)*2
        x = (m[9]-m[8])/S
        y = (m[2]-m[8])/S
        z = (m[4]-m[1])/S

        w = 0.25 * S

    Если Т матрицы равен 0, тогда определяется какой элемент главной 
    диагонали матрицы имеет большее значение.

    Опираясь на это имеем следующий расчет:

    if(m[0] > m[5] && m[0] > m[10])     // столбец 0
    {
        S = sqrt(1.0f + m[0] - m[5] - m[10]) * 2;
        x = 0.25f * S;
        y = (m[4] + m[1]) / S;
        z = (m[2] + m[8]) / S;
        w = (m[9] + m[6]) / S;
    }
    else if(m[5] > m[10])               // столбец 1
    {
        S = sqrt(1.0f + m[5] - m[0] - m[10]) * 2;
        x = (m[4] + m[1]) / S;
        y = 0.25f * S;
        z = (m[9] + m[6]) / S;
        w = (m[8] - m[8]) / S;
    }
    else                                // столбец 2
    {
        S = sqrt(1.0f + m[10] - m[0] - m[5]) * 2;
        x = (m[2] + m[8]) / S;
        y = (m[9] + m[6]) / S;
        z = 0.25f * S;
        w = (m[4] - m[1]) / S;
    }

    полученный кватернион: Q = |xyz w|

90. ПОЛУЧЕНИЕ КВАТЕРНИОНА ИЗ ОСИ ВРАЩЕНИЯ И УГЛА
------------------------------------------------

    w = cos(angle / 2.0f)

    x = axisx * ( sin(angle/2.0f)  )
    y = axisy * ( sin(angle/2.0f)  )
    z = axisz * ( sin(angle/2.0f)  )

    алгоритм:

    vector_normalize(axis)
    sin_a = sin(angle/2.0f)
    cos_a = cos(angle/2.0f)

    x = axis[x] * sin_a
    y = axis[y] * sin_a
    z = axis[z] * sin_a
    w = cos_a

    очень важно нормализовать кватернион в случае, когда его значения 
    очень близки к нулю

91. ПОЛУЧЕНИЕ ОСИ ВРАЩЕНИЯ И УГЛА ИЗ КВАТЕРНИОНА
------------------------------------------------

    quaternion_normalize(x,y,z,w)
    cos_a = W
    angle = acos(cos_a)*2
    sin_a = sqrt(1.0f - cos_a*cos_a)

    if(fabs(sin_a) < 0.0005f) sin_a = 1

    axis[x] = x/sin_a
    axis[y] = y/sin_a
    axis[z] = z/sin_a

92. ПОЛУЧЕНИЕ КВАТЕРНИОНА ИЗ УГЛОВ СФЕРИЧЕСКОГО ВРАЩЕНИЯ
--------------------------------------------------------

    Ось вращения может быть определена с использованием сферических координат
    (широта и долгота) (latitude and longitude) и угла вращения.

    sin_a = sin(angle/2)
    cos_a = cos(angle/2)
    sin_lat = sin(latitude)
    cos_lat = cos(latitude)
    sin_long = sin(longitude)
    cos_long = cos(longitude)

    x = sin_a * cos_lat * sin_long
    y = sin_a * sin_lat
    z = sin_a * sin_lat * cos_long
    w = cos_a

    Альтернативный вариант - получение кватерниона из углов Эйлера

93. ПОЛУЧЕНИЕ КВАТЕРНИОНОВЫХ УГЛОВ СФЕРИЧЕСКОГО ВРАЩЕНИЯ
--------------------------------------------------------

    cos_a = w
    sin_a = sqrt(1.0f - cos_a*cos_a)
    angle = acos(cos_a)*2

    if(fabs(sin_angle) < 0.0005) sin_a = 1

    tx = x/sin_a
    ty = y/sin_a
    tz = z/sin_a

    latitude = -asin(ty)

    if(tx*tx + tz*tz < 0.000005f)
    {
        latitude = 0
    }
    else 
    {
        longitude = atan2(tx,tz)
    }

    if(longitude < 0) longitude += 360.0f

94. ПРЕОБРАЗОВАНИЕ УГЛОВ ЭЙЛЕРА В КВАТЕРНИОН
--------------------------------------------

    Преобразование углов Эйлера в кватернион достигается через использование перемножения
    кватернионов. Каждый угол преобразуется в пару ось угол, где ось соответствует одной из
    эйлеровых осей. Пара ось угол преобразуется в кватернионы и перемножаются вместе.

    Финальный кватернион будет иметь жалемый результат.

    Алгоритм:

    void quaternion_from_euler(Q* q, float rx, float ry, float rz)
    {
        V3 vx = {1,0,0}, vy = {0,1,0}, vz = {0,0,1};    
        Q qx, qy, qz, qt;

        quaternion_from_axis_angle(qx, &vx, rx)
        quaternion_from_axis_angle(qy, &vy, ry)
        quaternion_from_axis_angle(qz, &vz, rz)

        quaternion_multiply(&qt, &qx, &qy)
        quaternion_multiply(&q,  &qt, &qz)
    }

    Оптимизированный вариант:

    void quaternion_from_euler(Q* q, float axisa[3])
    {
        float fSinPitch = sin(axisa[pitch]*0.5f)
        float fCosPitch = cos(axisa[pitch]*0.5f)
        float fSinYaw = sin(axisa[yaw]*0.5f)
        float fCosYaw = cos(axisa[yaw]*0.5f)
        float fSinRoll = sin(axisa[roll]*0.5f)
        float fCosRoll = cos(axisa[roll]*0.5f)

        float fCosPitchCosYaw = fCosPitch*fCosYaw
        float fSinPitchSinYaw = fSinPitch*fSinYaw

        q[x] = fSinRoll*fCosPitchCosYaw - fCosRoll*fSinPitchSinYaw
        q[y] = fCosRoll*fSinPitch * fCosYaw + fSinRoll*fCosPitch*fSinYaw
        q[z] = fCosRoll*fCosPitch*fSinYaw - fSinRoll*fSinPitch*fCosYaw
        q[w] = fCosRoll*fCosPitchCosYaw + fSinRoll*fSinPitchSinYaw
    }

95. ВРАЩЕНИЕ ВЕКТОРА ИСПОЛЬЗУЯ КВАТЕРНИОН
-----------------------------------------

    Можно напрямую вращать вектор вокруг кватернионовой оси

    V1 = Qrotate * V * Qrotate^-1

    1. вектор представляется как 4В
    2. умножается на Qrotate
    3. умножается на Qrotate^-1 (точнее Qrotate^-1 умножается на (Qrotate*V)
    4. 4Д представляется в виде 3Д усечением 4го значения

98. ДВОИЧНАЯ АЛГЕБРА
--------------------

    Определение:
    а. Используются логические операции AND,OR,XOR
    б. Положительные и отрицательные числа

    Для преобразования отрицательного числа в положительные (и наоборот)
        Инвертируются все биты числа (NOR)
        к результату прибавляется 1

    5 = 0101 NOT 1010 ADD1 1011 = -5
    -5 = 1011 NOT 0100 ADD1 0101 = 5

    0 = 0000 NOT 1111 ADD1 0000 = 0

    исходя из того, чот знаковый бит дописывается к значению:

    3 - 011 - максимальное положительное
    -4 - 101 - максимальное отрицательное

    Исходя из задаваемой системы конверсии мы можем преобразовать меньшие 
    значения в большие:

    011 = 000 011      для положительного
    101 = 111 101      для отрицательного

            011     (N)     100     (+1)        101 | - отрицательное расширение
        000 011     (N) 111 100     (+1)    111 101 |

    в. Сдвиг влево дает умножение на х2, вправо деление на х2

    001 (<<) 010 <=> 1*2=2
    011 (>>) 001 <=> 3/2=1  (1 остаток - вылетевший бит)

    Применение:
    Бинарные операторы принимая два значения возвращают одно.

    Постулаты:
    1. Замкнутость - система из 2х Б-значений возвращает Б-значение.
    2. Обратимость - оператор (op1) называют обращаемым, если A(op1)B = B(op1)A, для всех
                     возможных значениях B и А.
    3. Ассоциативность - оператор (op2) называют ассоциативным, если:
                     A (op2) (B (op2) A) = (A (op2) B) (op2) C
                     для всех возможных значений A,B,C
    4. Дистрибутивность - операторы (op1) и (op2) называют дистрибутивными, если
                     A(op1)(B(op2)C) = (A(op1)B) (op2) (A(op1)C)
                     для всех возможных значений A,B,C
    5. Идентичность - двоичное значение I называют элементом идентичности
                      если наблюдаем:
                      A (op1) I = A
    6. Инверсивность - двоичное значение I называют инверсивным, 
                      если имеем:
                      A (op1) I = B, B!=A
                      (т.е. противоположное значение А в двоичной системе)
    
    В бинарной алгебре используют операции:

    * - AND - еще называют product AD
    + - OR  - еще называют sum AD
    ! - NOT(A) - иногда записывают как A^1

    and/or - левоассоциативные
    not - правоассоциативный

    Набор постулатов:

    P1 - двоичная алгебра ограничена and/or/not
    P2 - элемент идентичности для операции and равен 1
         а для операции or равен 0
    P3 - оператор AND и оператор OR коммутативны
    P4 - операторы AND/OR дистрибутивны, при применении одного к другому
        A*(B+C) = (A*B)+(A*C)
        A+(B*C) = (A+B)*(A+C)
        т.е. результат есть общие элементы с A,B,C
    P5 - для каждого значения А есть такое !А, при котором
        A*!A = 0        A+!A = 1
    P6 - операции and/or ассоциативны, т.е.:
        A*(B*C) = (A*B)*C
        A+(B+C) = (A+B)+C

    Теоремы Б-алгебры: (строятся на базе постулатов)

    Th1:  A+A = A
    Th2:  A*A = A
    Th3:  A+0 = A
    Th4:  A*1 = A
    Th5:  A*0 = 0
    Th6:  A+1 = 1
    Th7:  !(A+B) = !A * !B
    Th8:  !(A*B) = !A + !B
    Th9:  A + A*B = A
    Th10: A * (A+B) = A
    Th11: A + (!A * B) = A + B
    Th12: !A * (A+!B) = !A * !B
    Th13: A + (!A * B) = A + B
    Th14: (!A + !B) = (!A + B) = !A
    Th15: A + !A = 1
    Th16: A * !A = 0

99. ЛОГАРИФМЫ
-------------

    Логарифм это функция, возвращающая степень в которую требуется возвести 
    число, переданное как база логарифма, чтобы получить заднное число

    log2(8) = 3 (т.к. 2^3 = 8, 2^3 - основание)
    
    Логарифмы могут возвращать нецелые степени:

    log2(20) 4.322, т.к. 2^(2.4.322) = 20

    Логарифмы удобно использовать для умножения чисел:
        к примеру ищем: x*y - logn(x*y)
        исходя из: a^a + a^b = a^(a+b) => x*y = lognx+ logny

    пример:
        26.50 * 0.43 = logn(26.50*0.43) = logn(26.50) + logn(0.43)
        при n = 2
        logn(26.50) = 4.728
        logn(0.43) = -1.218, 4.728 + (-1.218) = 3.51
        2.65 + 0.43 = 3.51

    то есть имея в наличии таблицу результатов расчета логарифмов
    можно заменить умножение сложением.

    Следует отметить, что lognx с увеличением числа x растет очень медленно:
    log21000 = 3.966
    log21000000 = 19.93

    log21 = 0
    log2(1/x) = -log2x

    логарифмы по основанию е(2.7182) называют натуральными

100. ФИГУРЫ ЛИССАНЖУ (КРИВЫЕ)
-----------------------------

    Общий виж фигур задается параметрами:

    x = sin(width * angle)
    y = cos(height * angle)

    где width/height - определяют внешний вид фигуры, а angle - есть параметр (t)

102. ФОРМУЛЫ ПРИВЕДЕНИЯ
------------------------

    Используя формулы приведения вычисляют 90 градусные промежутки sin/cos
    в градусах:

    sin(x) = sin(x)         при 0<x<90
    sin(x) = -sin(x-180)    при 90<x<180
    sin(x) = -sin(360-x)    при 270<x<360
    cos(x) = sin(90-x)

105. ПРЕОБРАЗОВАНИЕ ЧЕРЕЗ КОЭФИЦИЕНТЫ
--------------------------------------

    Можно преобразовать координаты рабочей сетки для более простых расчетов
    игнорирующих маштабирование данной сетки:

    -10+10                  +10+10
                  |
                  | Px1          P3
    ------------------------------      по формуле: Pn = Pn / (width/2)
                  |
                  |
    -10-10                  +10-10
    
    Px1 = 0/20/2 = 0
    Px2 = -10/20/2 = -1
    Px3 = +10/20/2 = 1

    Из чего координаты могут иметь вид:

    -1.1                       1.1
                  |
                  |
    ------------------------------
                  |
                  |
    -1.-1                       1.-1

    Важное условие для таких преобразований:

    Xmin            Xmax
    --------------------                abx(Xmin) == abs(Xmax)
    |                  |
    |                  |
    |__________________|

    Также исходя из формулы Pn = Pn / (width/k)  - изменяется К
    будем получать изменения координатной оси:

    К=3
    ---------------------------                 _____________ K02
    |       ------------      |                 |     |     |
    |       |     |    |      |         K=1     |-----------|
    |       |----------|      |                 |_____|_____| K01
    |       |_____|____| K01  |
    |_________________________| K02

    Условия преобразований (abs(Xmin) == abs(Xmax)) сохраняется.

106. РАЗМЕЩЕНИЕ НА СФЕРЕ 3Д ТОЧКИ И 2Д ПРОЕКЦИИ НА НЕЁ
------------------------------------------------------

    Подразумевается, что мы из экрана проецируем курсор на сферу
    или из какой то плоскости проецируем точку на сферу.

    Алгоритм:

    1. Считаем указанную длину сдвиги по x.y от центра система координат
        R = pt[x]*pt[x] + pt[y]*pt[y]

    2. Считаем уквадраченный радиус от сферы:
        radsq = radius * radius

    3. Проверяем на R>radsq ситуацию, т.е. на ситуацию когда XY координаты
    лежат за границами XY расположения сферы и произведем коррекцию
    (хотя можно закончить, возвратив полученный результат)

    if(R > radsq)
    {
        float S = radius / sqrt(R);
        result = {pt[x]*S, pt[y]*S, 0};
    }

    4. Если же выхода за границы сферы нет, расчитает правильные x.y.z

    result = {pt[x], pt[y], sqrt(radsq-R)};
                            сфера круглая, поэтому z == сдвигу
                            по любой оси на длину radius-R

107. ARCVIEW CONTROL
--------------------

    AV контроль это получение двух кватернионов вращения со сферы
    и дальнейшее преобразование их в матрицу вращения.

    Для создания контроля:
    1. Размещаем на 3В сфере точки из 2Д проекции
    2. из 2х векторов получаем кватернион, в котором
        alpha   = угол вращения 
        СfA     = угол вращения и кватернион
    3. Преобразуем кватернион в матрицу, которой можно вращать 
    объекты вокруг центра сферы AV контроля
       
       CfA        (A)
         \      .....
          \ _d^^^^|^^^^^b_ (B)
         .d''     |     ``b.
       .p'  \     |      / `q.
      .d'    \    |     /   `b.
     .d'      \   |    /     `b.
     ::        \  | alpha     ::
     ::         \ x.........> :: 
     ::         (C)           ::
     `p.                     .q'
      `p.                   .q'
       `b.                .d'
         `q..          ..p'
            ^q........p^
                '''''

    Алгоритм:
    1) 
    Vector3D_a = MapToSphere(&Vector2D_a);
    Vector3D_b = MapToSphere(&Vector2D_b)

    2)
    float w = Dot(Vector3D_a, Vector3D_b)

    хотя w и должен быть cos(theta/2)
    мы можем использовать и просто cos(theta), полученный через DotProduct

    Vector3D_Perpend = Cross(Vector3D_a, Vector3D_b)

    не забываем нормализовать полученное значение для точного расчета
    float normalized_value = Vector3D_Perpend.getLength();

    также normalized_value используем для проверки ситуации паралельных
    векторов, хотя для AV этого и не требуется

    if(normalized_value < EPSILON) return;

    float theta = acos(w)/2.0f;
    w = cos(theta);
    Vactor3D_Perpend = Vector3D_Perpend / normalized_value * sin(theta);

    3) строим матрицу из кватерниона:
    MatrixRot = QuaternionMatrix(&Vector3D_Perp, w);

    используется следующая формула построения матрицы из кватерниона (unit):

    w^2+x^2-y^2-z^2       2*(xy+wz)           2*(xz-wy)          0
    2*(xy - wz)           w^2-x^2+y^2-z^2     2*(yz+wx)          0
    2*(xz+wy)             2*(yz-wx)           w^2-x^2-y^2+z^2    w^2+x^2+y^2+z^2

108. ДЕЛЕНИЕ СЕКУНДЫ
--------------------
    1Мs микро = 1 миллионная секунды
    1ns нано  = 1 миллиардная секунды
    1ms милли = 1 тысячная секунлы

109. ИНДЕКСИРОВАНИЕ В РАМКАХ МАССИВА
------------------------------------
    1. построить сумму длин
    2. на базе лерп вычислить длину нужну
    3. двигаться постепенно от точки к точки - вычисляя достаточная ли длина
    4. в рамках точки построить вторую длину остаток и построить лерп внутри 
       этого отрезка

111. ПЕРЕСЕЧЕНИЕ ЛИНИИ И ЛИНИИ
------------------------------

    актуально в 2Д для простой обработки столкновений

    Ищеться в 2а шага:
    
    1. имеется пересечение линии (а) с плоскостью линии (с)

    \    |
     \   |
      \  |
       \ |
        \|          N - нормаль задана из 2DCrossProduct произвольной точки
   ------\ (a)      линии с центром системы в которой находится линия
   N     |
         |
         (b)

    2. теперь остается лишь найти соотнесение полученной точки пересечения
    с линиями (a) и (b) чтобы определить позицию пересечения.

    данный метод работает лишь в 2Д (или вырожденном 3Д)
